{
  "default_hooks": {
    "modules": {
      "fns": {}
    },
    "classes": {
      "fns": {
        "pypads_init": [
          "__init__"
        ],
        "pypads_fit": [
          "fit",
          "fit_predict",
          "fit_transform"
        ],
        "pypads_predict": [
          "fit_predict",
          "predict",
          "score"
        ],
        "pypads_transform": [
          "fit_transform",
          "transform"
        ]
      }
    },
    "fns": {}
  },
  "algorithms": [
    {
      "name": "base sklearn estimator",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.base.BaseEstimator"
      },
      "hooks": {
        "pypads_fit": [
          "fit",
          "fit_predict",
          "fit_transform"
        ],
        "pypads_predict": [
          "fit_predict",
          "predict$"
        ],
        "pypads_transform": [
          "fit_transform",
          "transform"
        ]
      }
    },
    {
      "name": "sklearn classification metrics",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.metrics.classification"
      },
      "hooks": {
        "pypads_metric": [
          "^(?!_).*"
        ]
      }
    },
    {
      "name": "sklearn datasets",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.datasets.base"
      },
      "hooks": {
        "pypads_dataset": [
          "load_iris",
          "load_digits"
        ]
      }
    },
    {
      "name": "sklearn cross validation grid search",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.model_selection._search.BaseSearchCV"
      },
      "hooks": {
        "pypads_param_search": [
          "fit"
        ],
        "pypads_fit": [
          "fit"
        ],
        "pypads_predict": [
          "predict$"
        ]
      }
    },
    {
      "name": "sklearn cross validation fit_score",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.model_selection._validation._fit_and_score"
      },
      "hooks": {
        "pypads_param_search_exec": "always"
      }
    },
    {
      "name": "sklearn cross validation",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.model_selection._split.BaseCrossValidator"
      },
      "hooks": {
        "pypads_split": [
          "split"
        ]
      }
    },
    {
      "name": "sklearn shuffle split",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.model_selection._split.BaseShuffleSplit"
      },
      "hooks": {
        "pypads_split": [
          "split"
        ]
      }
    },
    {
      "name": "base sklearn regressor mixin",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.base.RegressorMixin"
      },
      "hooks": {
        "pypads_metric": [
          "score"
        ]
      }
    },
    {
      "name": "base sklearn classifier mixin",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.base.ClassifierMixin"
      },
      "hooks": {
        "pypads_metric": [
          "score"
        ]
      }
    },
    {
      "name": "base sklearn density mixin",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.base.DensityMixin"
      },
      "hooks": {
        "pypads_metric": [
          "score"
        ]
      }
    },
    {
      "name": "linear regression",
      "wikidata_id": "Q10861030",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.base.LinearRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "range": "{True, False}",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "measurement_scale": "nominal",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "range": "{True, False}",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "measurement_scale": "nominal",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "range": "{True, False}",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "measurement_scale": "nominal",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "range": "Z >= -1",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "measurement_scale": "ratio",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "ridge regression",
      "other_names": [
        "Tikhonov regularization",
        "weight decay",
        "Tikhonov\\u2013Miller method",
        "Phillips\\u2013Twomey method",
        "constrained linear inversion",
        "linear regularization"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.ridge.Ridge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "string",
            "range": "{'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}",
            "optional": "False",
            "description": "Solver to use in the computational routines.",
            "measurement_scale": "nominal",
            "sklearn": {
              "default_value": "'auto'",
              "path": "solver"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "lasso",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.coordinate_descent.Lasso"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1 term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tolerance, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "sklearn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'cyclic', 'random'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "sklearn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "precompute",
            "kind_of_value": "{boolean, array-like, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "sklearn": {
              "default_value": "False",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-task lasso",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.coordinate_descent.MultiTaskLasso"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'random', 'cyclic'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "sklearn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "elastic net",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.coordinate_descent.ElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "sklearn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "sklearn": {
              "default_value": "False",
              "path": "positive"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'random', 'cyclic'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "sklearn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{boolean, array-like, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "sklearn": {
              "default_value": "False",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-task elastic net",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.coordinate_descent.MultiTaskElasticNet"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "l1_l2_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the L1/L2 term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an L2 penalty. For l1_ratio = 1 it is an L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "sklearn": {
              "default_value": "0.5",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The tolerance for the optimization: if the updates are smaller than tol, the optimization code checks the dual gap for optimality and continues until it is smaller than tol.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "selection",
            "kind_of_value": "{'random', 'cyclic'}",
            "optional": "False",
            "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default.",
            "sklearn": {
              "default_value": "'cyclic'",
              "path": "selection"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "least angle regression",
      "other_names": [
        "LARS"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.least_angle.Lars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "sklearn": {
              "default_value": "500",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "sklearn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "sklearn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{boolean, array-like, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "sklearn": {
              "default_value": "False",
              "path": "precompute"
            }
          },
          {
            "name": "fit_path",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If True the full path is stored in the coef_path_ attribute. If you compute the solution for a large problem or many targets, setting fit_path to False will lead to a speedup, especially with a small alpha.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_path"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "lasso least angle regression",
      "other_names": [
        "LassoLars"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.least_angle.LassoLars"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_multiplier",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Constant that multiplies the penalty term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "{boolean, integer}",
            "optional": "True",
            "description": "Sets the verbosity amount.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the I2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",
            "sklearn": {
              "default_value": "2.2204460492503131e-16",
              "path": "eps"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "positive_coef",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, forces the coefficients to be positive.",
            "sklearn": {
              "default_value": "False",
              "path": "positive"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "fit_path",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If True the full path is stored in the coef_path_ attribute. If you compute the solution for a large problem or many targets, setting fit_path to False will lead to a speedup, especially with a small alpha.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_path"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "orthogonal matching pursuit model",
      "other_names": [
        "OMP"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.omp.OrthogonalMatchingPursuit"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nonzero_coef",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Target number of non-zero coefficients.",
            "sklearn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "sklearn": {
              "default_value": "True",
              "path": "normalize"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "False",
            "description": "Whether to use a precomputed Gram matrix  and Xy matrix to speed up calculations. Matrices can also be directly passed to the fit method.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "n-target orthogonal matching pursuit",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.orthogonal_mp"
      },
      "type": "Model Fit Aproximator",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "feature_matrix",
            "kind_of_value": "array, shape (n_samples, n_features)",
            "optional": "False",
            "description": "Input data. Columns are assumed to have unit norm.",
            "sklearn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "input_targets",
            "kind_of_value": "array, shape (n_samples) or (n_samples, n_targets)",
            "optional": "False",
            "description": "Input targets",
            "sklearn": {
              "default_value": "",
              "path": "Y"
            }
          },
          {
            "name": "nonzero_coefficients",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Target number of non-zero coefficients.",
            "sklearn": {
              "default_value": "None",
              "path": "n_nonzero_coefs"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum norm of the residual.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "return_path",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to return every value of the nonzero coefficients along the forward path. Useful for cross-validation.",
            "sklearn": {
              "default_value": "False",
              "path": "return_path"
            }
          },
          {
            "name": "return_n_iter",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not to return the number of iterations.",
            "sklearn": {
              "default_value": "False",
              "path": "return_n_iter"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "precompute",
            "kind_of_value": "{True, False, 'auto'}",
            "optional": "False",
            "description": "Whether to perform precomputations.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "precompute"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bayesian ridge regression",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.bayes.BayesianRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "sklearn": {
              "default_value": "0.000006",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "sklearn": {
              "default_value": "0.000006",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "sklearn": {
              "default_value": "0.000006",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "sklearn": {
              "default_value": "0.000006",
              "path": "lambda_2"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Verbose mode when fitting the model.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "300",
              "path": "n_iter"
            }
          },
          {
            "name": "compute_score",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, compute the objective function at each step of the model.",
            "sklearn": {
              "default_value": "False",
              "path": "compute_score"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "automatic relevance determination regression",
      "other_names": [
        "ARD regrssion"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.bayes.ARDRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "alpha_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the alpha parameter.",
            "sklearn": {
              "default_value": "1e-06",
              "path": "alpha_1"
            }
          },
          {
            "name": "alpha_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
            "sklearn": {
              "default_value": "1e-06",
              "path": "alpha_2"
            }
          },
          {
            "name": "lambda_1",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Shape parameter for the Gamma distribution prior over the lambda parameter.",
            "sklearn": {
              "default_value": "1e-06",
              "path": "lambda_1"
            }
          },
          {
            "name": "lambda_2",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
            "sklearn": {
              "default_value": "1e-06",
              "path": "lambda_2"
            }
          },
          {
            "name": "threshold_lambda",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold for removing (pruning) weights with high precision from the computation.",
            "sklearn": {
              "default_value": "10000.0",
              "path": "threshold_lambda"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "normalize",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Normalizes the regressors before regression by subtracting the mean and dividing by the l2-norm.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Verbose mode when fitting the model.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "300",
              "path": "n_iter"
            }
          },
          {
            "name": "compute_score",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, compute the objective function at each step of the model.",
            "sklearn": {
              "default_value": "False",
              "path": "compute_score"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "logistic regression",
      "other_names": [
        "logit regression",
        "maximum-entropy classification",
        "MaxEnt",
        "log-linear classifier"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.logistic.LogisticRegression"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_norm",
            "kind_of_value": "{l1, l2}",
            "optional": "False",
            "description": "Used to specify the norm used in the penalization.",
            "sklearn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Dual or primal formulation.",
            "sklearn": {
              "default_value": "False",
              "path": "dual"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance for stopping criteria.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "inverse_regularisation_strength",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "intercept_scaling",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Useful only when the solver \\u2018liblinear\\u2019 is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a \\u201csynthetic\\u201d feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight.",
            "sklearn": {
              "default_value": "1",
              "path": "intercept_scaling"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'}",
            "optional": "False",
            "description": "Solver to use in the computational routines.",
            "sklearn": {
              "default_value": "'liblinear'",
              "path": "solver"
            }
          },
          {
            "name": "multi_class",
            "kind_of_value": "{'ovr', 'multinomial'}",
            "optional": "False",
            "description": "If the option chosen is \\u2018ovr\\u2019, then a binary problem is fit for each label. Else the loss minimised is the multinomial loss fit across the entire probability distribution.",
            "sklearn": {
              "default_value": "'ovr'",
              "path": "multi_class"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "For the liblinear and lbfgs solvers set verbose to any positive number for verbosity.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of CPU cores used when parallelizing over classes.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent classifier",
      "other_names": [
        "SGD classifier"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.stochastic_gradient.SGDClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'log', 'modified_huber', 'squared_hinge', 'perceptron', 'squared_loss', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "sklearn": {
              "default_value": "'hinge'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "sklearn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "sklearn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not the training data should be shuffled after each epoch.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The verbosity level.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "False",
            "description": "For \\u2018huber\\u2019, determines the threshold at which it becomes less important to get the prediction exactly right. For epsilon-insensitive, any differences between the current prediction and the correct label are ignored if they are less than this threshold.",
            "sklearn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{constant, optimal, invscaling}",
            "optional": "True",
            "description": "Where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "sklearn": {
              "default_value": "optimal",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "sklearn": {
              "default_value": "0.0",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "sklearn": {
              "default_value": "0.5",
              "path": "power_t"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, 'balanced',  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "average",
            "kind_of_value": "{boolean, integer}",
            "optional": "True",
            "description": "When set to True, computes the averaged SGD weights and stores the result in the coef_ attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches average. So average=10 will begin averaging after seeing 10 samples.",
            "sklearn": {
              "default_value": "False",
              "path": "average"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use to do the OVA (One Versus All, for multi-class problems) computation. -1 means 'all CPUs'.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "stochastic gradient descent regressor",
      "other_names": [
        "SGD regressor"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.stochastic_gradient.SGDRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss_function",
            "kind_of_value": "{'squared_loss', 'huber', 'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "sklearn": {
              "default_value": "'squared_loss'",
              "path": "loss"
            }
          },
          {
            "name": "regularization_term",
            "kind_of_value": "{'none', 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "sklearn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "regualrisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The Elastic Net mixing parameter.",
            "sklearn": {
              "default_value": "0.15",
              "path": "l1_ratio"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not the training data should be shuffled after each epoch.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The verbosity level.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "False",
            "description": "For \\u2018huber\\u2019, determines the threshold at which it becomes less important to get the prediction exactly right. For epsilon-insensitive, any differences between the current prediction and the correct label are ignored if they are less than this threshold.",
            "sklearn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'optimal', 'invscaling'}",
            "optional": "True",
            "description": "where t0 is chosen by a heuristic proposed by Leon Bottou.",
            "sklearn": {
              "default_value": "'invscaling'",
              "path": "learning_rate"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "sklearn": {
              "default_value": "0.01",
              "path": "eta0"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The exponent for inverse scaling learning rate.",
            "sklearn": {
              "default_value": "0.25",
              "path": "power_t"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "average",
            "kind_of_value": "{boolean, integer}",
            "optional": "True",
            "description": "When set to True, computes the averaged SGD weights and stores the result in the coef_ attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches average. So average=10 will begin averaging after seeing 10 samples.",
            "sklearn": {
              "default_value": "False",
              "path": "average"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "perceptron",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.perceptron.Perceptron"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularization_term",
            "kind_of_value": "{none, 'l2', 'l1', 'elasticnet'}",
            "optional": "False",
            "description": "The penalty (aka regularization term) to be used.",
            "sklearn": {
              "default_value": "None",
              "path": "penalty"
            }
          },
          {
            "name": "regularisation_multiplier",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Constant that multiplies the regularization term.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not the training data should be shuffled after each epoch.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The verbosity level.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "eta0",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The initial learning rate for the 'constant' or 'invscaling' schedules.",
            "sklearn": {
              "default_value": "1.0",
              "path": "eta0"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{{class_label: weight}, 'balanced',  None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.passive_aggressive.PassiveAggressiveClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not the training data should be shuffled after each epoch.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The verbosity level.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'squared_hinge'}",
            "optional": "True",
            "description": "The loss function to be used.",
            "sklearn": {
              "default_value": "'hinge'",
              "path": "loss"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict,'balanced', None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "average",
            "kind_of_value": "{boolean, integer}",
            "optional": "True",
            "description": "When set to True, computes the averaged SGD weights and stores the result in the coef_ attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches average. So average=10 will begin averaging after seeing 10 samples.",
            "sklearn": {
              "default_value": "False",
              "path": "average"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of of CPUs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "passive aggressive regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.passive_aggressive.PassiveAggressiveRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regualrisation",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Maximum step size (regularization).",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether the intercept should be estimated or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "sklearn": {
              "default_value": "None",
              "path": "tol"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not the training data should be shuffled after each epoch.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The verbosity level.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "True",
            "description": "The loss function to be used.",
            "sklearn": {
              "default_value": "'epsilon_insensitive'",
              "path": "loss"
            }
          },
          {
            "name": "update_threshold",
            "kind_of_value": "float",
            "optional": "False",
            "description": "If the difference between the current prediction and the correct label is below this threshold, the model is not updated.",
            "sklearn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "average",
            "kind_of_value": "{boolean, integer}",
            "optional": "True",
            "description": "When set to True, computes the averaged SGD weights and stores the result in the coef_ attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches average. So average=10 will begin averaging after seeing 10 samples.",
            "sklearn": {
              "default_value": "False",
              "path": "average"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "epochs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of passes over the training data (aka epochs).",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random sample consensus regressor",
      "other_names": [
        "RANSAC"
      ],
      "implementation": {
        "sklearn": "sklearn.linear_model.ransac.RANSACRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "sklearn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "min_samples",
            "kind_of_value": "[int (>= 1), float ([0, 1])}",
            "optional": "True",
            "description": "Minimum number of samples chosen randomly from original data.",
            "sklearn": {
              "default_value": "None",
              "path": "min_samples"
            }
          },
          {
            "name": "residual_threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Maximum residual for a data sample to be classified as an inlier. By default the threshold is chosen as the MAD (median absolute deviation) of the target values y.",
            "sklearn": {
              "default_value": "None",
              "path": "residual_threshold"
            }
          },
          {
            "name": "is_data_valid",
            "kind_of_value": "callable",
            "optional": "True",
            "description": "This function is called with the randomly selected data before the model is fitted to it: is_data_valid(X, y). If its return value is False the current randomly chosen sub-sample is skipped.",
            "sklearn": {
              "default_value": "None",
              "path": "is_data_valid"
            }
          },
          {
            "name": "is_model_valid",
            "kind_of_value": "callable",
            "optional": "True",
            "description": "This function is called with the estimated model and the randomly selected data: is_model_valid(model, X, y). If its return value is False the current randomly chosen sub-sample is skipped. Rejecting samples with this function is computationally costlier than with is_data_valid. is_model_valid should therefore only be used if the estimated model is needed for making the rejection decision..",
            "sklearn": {
              "default_value": "None",
              "path": "is_model_valid"
            }
          },
          {
            "name": "loss",
            "kind_of_value": "{'absolute_loss', 'squared_loss'}",
            "optional": "True",
            "description": "If loss is a callable, then it should be a function that takes two arrays as inputs, the true and predicted value and returns a 1-D array with the i-th value of the array corresponding to the loss on X[i].",
            "sklearn": {
              "default_value": "absolute_loss",
              "path": "loss"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "iterations_random_sampling",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for random sample selection.",
            "sklearn": {
              "default_value": "100",
              "path": "max_trials"
            }
          },
          {
            "name": "max_skips",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations that can be skipped due to finding zero inliers or invalid data.",
            "sklearn": {
              "default_value": "inf",
              "path": "max_skips"
            }
          },
          {
            "name": "stop_n_inliers",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Stop iteration if at least this number of inliers are found.",
            "sklearn": {
              "default_value": "inf",
              "path": "stop_n_inliers"
            }
          },
          {
            "name": "stop_score",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stop iteration if score is greater equal than this threshold.",
            "sklearn": {
              "default_value": "inf",
              "path": "stop_score"
            }
          },
          {
            "name": "stop_probability",
            "kind_of_value": "float in range [0,1]",
            "optional": "True",
            "description": "RANSAC iteration stops if at least one outlier-free set of the training data is sampled in RANSAC.",
            "sklearn": {
              "default_value": "0.99",
              "path": "stop_probability"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "theil-sen estimator",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.theil_sen.TheilSenRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, X will be copied; else, it may be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          },
          {
            "name": "max_subpopulation",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Instead of computing with a set of cardinality \\u2018n choose k\\u2019, where n is the number of samples and k is the number of subsamples (at least number of features), consider only a stochastic subpopulation of a given maximal size if \\u2018n choose k\\u2019 is larger than max_subpopulation. For other than small problem sizes this parameter will determine memory usage and runtime if n_subsamples is not changed.",
            "sklearn": {
              "default_value": "10000",
              "path": "max_subpopulation"
            }
          },
          {
            "name": "num_subsamples",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of samples to calculate the parameters.",
            "sklearn": {
              "default_value": "None",
              "path": "n_subsamples"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance when calculating spatial median.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Verbose mode when fitting the model.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for the calculation of spatial median.",
            "sklearn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of CPUs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "huber regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.linear_model.huber.HuberRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "number_of_outliers",
            "kind_of_value": "float > 1.0",
            "optional": "False",
            "description": "The parameter controls the number of samples that should be classified as outliers. The smaller the parameter, the more robust it is to outliers.",
            "sklearn": {
              "default_value": "1.35",
              "path": "epsilon"
            }
          },
          {
            "name": "regularization_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization parameter.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The stopping criterion.",
            "sklearn": {
              "default_value": "1e-05",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations that scipy.optimize.fmin_l_bfgs_b should run for.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear discriminant analysis",
      "other_names": [
        "LDA"
      ],
      "implementation": {
        "sklearn": "sklearn.discriminant_analysis.LinearDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimation_algorithm",
            "kind_of_value": "{'svd', 'lsqr', 'eigen'}",
            "optional": "True",
            "description": "Possible values: singular value decomposition (svd), least squares solution (lsqr), eigenvalue decomposition (eigen)",
            "sklearn": {
              "default_value": "'svd'",
              "path": "solver"
            }
          },
          {
            "name": "shrinkage",
            "kind_of_value": "{None, 'auto', float between 0 and 1}",
            "optional": "True",
            "description": "Shrinkage is a tool to improve estimation of covariance matrices in situations where the number of training samples is small compared to the number of features. Possible values: no shrinkage (None), automatic shrinkage using the Ledoit-Wolf lemma (auto), fixed shrinkage parameter(float between 0 and 1)",
            "sklearn": {
              "default_value": "None",
              "path": "shrinkage"
            }
          },
          {
            "name": "priors",
            "kind_of_value": "array in shape of (n_classes,)",
            "optional": "True",
            "description": "Class priors.",
            "sklearn": {
              "default_value": "None",
              "path": "priors"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of components (< n_classes - 1) for dimensionality reduction.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "store_covariance",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Additionally compute class covariance matrix (default False), used only in \\u2018svd\\u2019 solver.",
            "sklearn": {
              "default_value": "False",
              "path": "store_covariance"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation in SVD solver.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "quadratic discriminant analysis",
      "other_names": [
        "QDA"
      ],
      "implementation": {
        "sklearn": "sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "priors",
            "kind_of_value": "array in shape of [n_classes]",
            "optional": "True",
            "description": "Class priors.",
            "sklearn": {
              "default_value": "None",
              "path": "priors"
            }
          },
          {
            "name": "regularisation_parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Regularizes the covariance estimate.",
            "sklearn": {
              "default_value": "0.0",
              "path": "reg_param"
            }
          },
          {
            "name": "store_covariance",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If True the covariance matrices are computed and stored in the self.covariance_ attribute.",
            "sklearn": {
              "default_value": "False",
              "path": "store_covariance"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold used for rank estimation.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "kernel ridge regression",
      "other_names": [
        "KRR"
      ],
      "implementation": {
        "sklearn": "sklearn.kernel_ridge.KernelRidge"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "regularisation_strength",
            "kind_of_value": "float, array-like in the shape of the targets",
            "optional": "False",
            "description": "Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Lambda corresponds to C^-1 in other linear models such as LogisticRegression or LinearSVC.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'cosine', 'gaussian', 'tophat', 'epanechnikov', 'exponential', 'precomputed', callable which accepts two arguments and the keyword arguments passed to this object as kernel_params, and should return a floating point number.}",
            "optional": "False",
            "description": "Kernel mapping used internally.",
            "sklearn": {
              "default_value": "'linear'",
              "path": "kernel"
            }
          },
          {
            "name": "gamma",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Gamma parameter for the RBF, laplacian, polynomial, exponential chi2 and sigmoid kernels. Interpretation depends on kernels.",
            "sklearn": {
              "default_value": "None",
              "path": "gamma"
            }
          },
          {
            "name": "kernel_degree",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Degree of the polynomial kernel.",
            "sklearn": {
              "default_value": "3.0",
              "path": "degree"
            }
          },
          {
            "name": "zero_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Zero coefficient for polynomial and sigmoid kernels.",
            "sklearn": {
              "default_value": "1.0",
              "path": "coef0"
            }
          },
          {
            "name": "kernel_parameters",
            "kind_of_value": "mapping of string to any",
            "optional": "True",
            "description": "Additional parameters (keyword arguments) for kernel function passed as callable object.",
            "sklearn": {
              "default_value": "None",
              "path": "kernel_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "c-oja pas vector classification",
      "other_names": [
        "SVC"
      ],
      "implementation": {
        "sklearn": "sklearn.svm.classes.SVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "sklearn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "sklearn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "probability",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to enable probability estimates. This must be enabled prior to calling fit, and will slow down that method.",
            "sklearn": {
              "default_value": "False",
              "path": "probability"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "sklearn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The \\u201cbalanced\\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Enable verbose output.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "decision_function_shape",
            "kind_of_value": "{'ovo', 'ovr'}",
            "optional": "False",
            "description": "Whether to return a one-vs-rest ('ovr') decision function of shape (n_samples, n_classes) as all other classifiers, or the original one-vs-one ('ovo') decision function of libsvm which has shape (n_samples, n_classes * (n_classes - 1) / 2).",
            "sklearn": {
              "default_value": "False",
              "path": "decision_function_shape"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "sklearn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "sklearn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector classification",
      "other_names": [
        "nuSVC"
      ],
      "implementation": {
        "sklearn": "sklearn.svm.classes.NuSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "sklearn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "sklearn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "sklearn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "sklearn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "probability",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to enable probability estimates. This must be enabled prior to calling fit, and will slow down that method.",
            "sklearn": {
              "default_value": "False",
              "path": "probability"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The \\u201cbalanced\\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Enable verbose output.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "decision_function_shape",
            "kind_of_value": "{'ovo', 'ovr'}",
            "optional": "False",
            "description": "Whether to return a one-vs-rest ('ovr') decision function of shape (n_samples, n_classes) as all other classifiers, or the original one-vs-one ('ovo') decision function of libsvm which has shape (n_samples, n_classes * (n_classes - 1) / 2).",
            "sklearn": {
              "default_value": "False",
              "path": "decision_function_shape"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "sklearn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "sklearn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector classification",
      "other_names": [
        "linear SVC"
      ],
      "implementation": {
        "sklearn": "sklearn.svm.classes.LinearSVC"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "penalty_norm",
            "kind_of_value": "{'l1', 'l2'}",
            "optional": "False",
            "description": "Specifies the norm used in the penalization.",
            "sklearn": {
              "default_value": "'l2'",
              "path": "penalty"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'hinge', 'squared_hinge'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "sklearn": {
              "default_value": "'squared_hinge'",
              "path": "loss"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "sklearn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criteria.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "multi_class_strategy",
            "kind_of_value": "{'ovr', 'crammer_singer'}",
            "optional": "False",
            "description": "Determines the multi-class strategy if y contains more than two classes.",
            "sklearn": {
              "default_value": "'ovr'",
              "path": "multi_class"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "intercept_scaling",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Useful only when the solver \\u2018liblinear\\u2019 is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a \\u201csynthetic\\u201d feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight.",
            "sklearn": {
              "default_value": "1",
              "path": "intercept_scaling"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dictionary with weights for all calsses, 'balanced', None}",
            "optional": "True",
            "description": "Weights the classes. The \\u201cbalanced\\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Enable verbose output.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "sklearn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "epsilon-support vector regression",
      "other_names": [
        "SVR"
      ],
      "implementation": {
        "sklearn": "sklearn.svm.classes.SVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value.",
            "sklearn": {
              "default_value": "0.1",
              "path": "epsilon"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "sklearn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float or 'auto'",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "sklearn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "sklearn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Enable verbose output.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "sklearn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "sklearn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nu-support vector regression",
      "other_names": [
        "nuSVR"
      ],
      "implementation": {
        "sklearn": "sklearn.svm.classes.NuSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "sklearn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "sklearn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "sklearn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "sklearn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Enable verbose output.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "sklearn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "sklearn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "linear-support vector regression",
      "other_names": [
        "linearSVR"
      ],
      "implementation": {
        "sklearn": "sklearn.svm.classes.LinearSVR"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "error_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Penalty parameter of the error term.",
            "sklearn": {
              "default_value": "1.0",
              "path": "C"
            }
          },
          {
            "name": "loss_function",
            "kind_of_value": "{'epsilon_insensitive', 'squared_epsilon_insensitive'}",
            "optional": "False",
            "description": "The loss function to be used.",
            "sklearn": {
              "default_value": "'epsilon_insensitive'",
              "path": "loss"
            }
          },
          {
            "name": "epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Epsilon parameter in the epsilon-insensitive loss function. Note that the value of this parameter depends on the scale of the target variable y.",
            "sklearn": {
              "default_value": "0.0",
              "path": "epsilon"
            }
          },
          {
            "name": "dual",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Select the algorithm to either solve the dual or primal optimization problem.",
            "sklearn": {
              "default_value": "True",
              "path": "dual"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "fit_intercept",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to calculate the intercept for this model.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_intercept"
            }
          },
          {
            "name": "intercept_scaling",
            "kind_of_value": "float",
            "optional": "True",
            "description": "When self.fit_intercept is True, instance vector x becomes [x, self.intercept_scaling], i.e. a \\u201csynthetic\\u201d feature with constant value equals to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic feature weight Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased.",
            "sklearn": {
              "default_value": "1",
              "path": "intercept_scaling"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Enable verbose output.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations to be run.",
            "sklearn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one-class support vector machine",
      "other_names": [
        "one-calss SVM"
      ],
      "implementation": {
        "sklearn": "sklearn.svm.classes.OneClassSVM"
      },
      "type": "Outlier Detection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "nu",
            "kind_of_value": "float (0, 1]",
            "optional": "True",
            "description": "An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1].",
            "sklearn": {
              "default_value": "0.5",
              "path": "nu"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'precomputed', a callable in shape (n_samples, n_samples)}",
            "optional": "True",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "poly_degree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Degree of the polynomial kernel function ('poly'). ",
            "sklearn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "{float, 'auto'}",
            "optional": "True",
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'. If kernel_coefficient is 'auto' then 1/n_features will be used instead.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "gamma"
            }
          },
          {
            "name": "independent_kernel_term",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
            "sklearn": {
              "default_value": "0.0",
              "path": "coef0"
            }
          },
          {
            "name": "shrinking",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use the shrinking heuristic.",
            "sklearn": {
              "default_value": "True",
              "path": "shrinking"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for stopping criterion.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Enable verbose output.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "cache_size",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Specify the size of the kernel cache (in MB).",
            "sklearn": {
              "default_value": "200",
              "path": "cache_size"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Hard limit on iterations within solver, or -1 for no limit.",
            "sklearn": {
              "default_value": "-1",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest neighbours",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.neighbors.unsupervised.NearestNeighbors"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use by default for kneighbors queries.",
            "sklearn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use by default for radius_neighbors queries.",
            "sklearn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'ball_tree', 'kd_tree', 'brute', 'auto'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "Metric to use for distance computation.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "sklearn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-d tree",
      "other_names": [
        "KDTree",
        "k-dimensional tree"
      ],
      "implementation": {
        "sklearn": "sklearn.neighbors.KDTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "feature_matrix",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "sklearn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'p', 'l1', 'chebyshev', 'manhattan', 'minkowski', 'cityblock', 'l2', 'euclidean', 'infinity'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "sklearn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "ball tree",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.neighbors.BallTree"
      },
      "type": "Search Tree",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "feature_matrix",
            "kind_of_value": "array, shape: [n_samples, n_features]",
            "optional": "False",
            "description": "n_samples is the number of points in the data set, and n_features is the dimension of the parameter space.",
            "sklearn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'seuclidean', 'hamming', 'dice', 'jaccard', 'matching', 'russellrao',  'euclidean', 'kulsinski', 'wminkowski', 'chebyshev', 'mahalanobis', 'sokalmichener', 'rogerstanimoto', 'infinity', 'p', 'canberra',  'haversine', 'sokalsneath', 'l1', 'minkowski', 'pyfunc', 'l2', 'cityblock', 'braycurtis', 'manhattan'}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "leaf_size",
            "kind_of_value": "positive integer",
            "optional": "False",
            "description": "Number of points at which to switch to brute-force. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree.",
            "sklearn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.neighbors.classification.RadiusNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "sklearn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "sklearn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "sklearn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "outlier_label",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Label, which is given for outlier samples (samples with no neighbors on given radius). If set to None, ValueError is raised, when outlier is detected.",
            "sklearn": {
              "default_value": "None",
              "path": "outlier_label"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn classifier",
      "other_names": [
        "k-nearest neighbors classifier"
      ],
      "implementation": {
        "sklearn": "sklearn.neighbors.classification.KNeighborsClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "sklearn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "sklearn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "sklearn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-nn regressor",
      "other_names": [
        "k-nearest neighbors regressor"
      ],
      "implementation": {
        "sklearn": "sklearn.neighbors.regression.KNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "n_neighbors",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use.",
            "sklearn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "sklearn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "sklearn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "radius neighbors regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.neighbors.regression.RadiusNeighborsRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "radius",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Range of parameter space to use.",
            "sklearn": {
              "default_value": "1.0",
              "path": "radius"
            }
          },
          {
            "name": "weight_function",
            "kind_of_value": "{'uniform', 'distance', callable: a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.}",
            "optional": "False",
            "description": "Weight function used in prediction.",
            "sklearn": {
              "default_value": "'uniform'",
              "path": "weights"
            }
          },
          {
            "name": "nn_algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "Algorithm used to compute the nearest neighbors.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Parameter for the Minkowski metric.",
            "sklearn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use for the tree.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "nearest centroid classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.neighbors.nearest_centroid.NearestCentroid"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "sklearn": {
              "default_value": "'euclidean''",
              "path": "metric"
            }
          },
          {
            "name": "shrink_threshold",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "Threshold for shrinking centroids to remove features.",
            "sklearn": {
              "default_value": "None",
              "path": "shrink_threshold"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian process regression",
      "other_names": [
        "GPR"
      ],
      "implementation": {
        "sklearn": "sklearn.gaussian_process.gpr.GaussianProcessRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "kernel object",
            "optional": "False",
            "description": "The kernel specifying the covariance function of the GP.",
            "sklearn": {
              "default_value": "None",
              "path": "kernel"
            }
          },
          {
            "name": "alpha",
            "kind_of_value": "{float, array}",
            "optional": "True",
            "description": "Value added to the diagonal of the kernel matrix during fitting. Larger values correspond to increased noise level in the observations. This can also prevent a potential numerical issue during fitting, by ensuring that the calculated values form a positive definite matrix. If an array is passed, it must have the same number of entries as the data used for fitting and is used as datapoint-dependent noise level. Note that this is equivalent to adding a WhiteKernel with c=alpha. Allowing to specify the noise level directly as a parameter is mainly for convenience and for consistency with Ridge.",
            "sklearn": {
              "default_value": "0.0000000001",
              "path": "alpha"
            }
          },
          {
            "name": "kernel_optimizer",
            "kind_of_value": "{'fmin_l_bfgs_b', externally defined optimizer passed as a callable }",
            "optional": "True",
            "description": "Optimizer to optimize the kernel parameters.",
            "sklearn": {
              "default_value": "'fmin_l_bfgs_b'",
              "path": "optimizer"
            }
          },
          {
            "name": "n_restarts_optimizer",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of restarts of the optimizer for finding the kernel's parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values.",
            "sklearn": {
              "default_value": "0",
              "path": "n_restarts_optimizer"
            }
          },
          {
            "name": "normalize_y",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether the target values y are normalized, i.e., the mean of the observed target values become zero. This parameter should be set to True if the target values' mean is expected to differ considerable from zero. When enabled, the normalization effectively modifies the GP's prior based on the data, which contradicts the likelihood principle.",
            "sklearn": {
              "default_value": "False",
              "path": "normalize_y"
            }
          },
          {
            "name": "copy_X_train",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, a persistent copy of the training data is stored in the object. Otherwise, just a reference to the training data is stored, which might cause predictions to change if the data is modified externally.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X_train"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian process classification",
      "other_names": [
        "GPC"
      ],
      "implementation": {
        "sklearn": "sklearn.gaussian_process.gpc.GaussianProcessClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "kernel object",
            "optional": "False",
            "description": "The kernel specifying the covariance function of the GP.",
            "sklearn": {
              "default_value": "None",
              "path": "kernel"
            }
          },
          {
            "name": "kernel_optimizer",
            "kind_of_value": "{'fmin_l_bfgs_b', externally defined optimizer passed as a callable }",
            "optional": "True",
            "description": "Optimizer to optimize the kernel parameters.",
            "sklearn": {
              "default_value": "'fmin_l_bfgs_b'",
              "path": "optimizer"
            }
          },
          {
            "name": "n_restarts_optimizer",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of restarts of the optimizer for finding the kernel's parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values.",
            "sklearn": {
              "default_value": "0",
              "path": "n_restarts_optimizer"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, the solution of the last Newton iteration on the Laplace approximation of the posterior mode is used as initialization for the next call, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "copy_X_train",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, a persistent copy of the training data is stored in the object. Otherwise, just a reference to the training data is stored, which might cause predictions to change if the data is modified externally.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X_train"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "multi_class",
            "kind_of_value": "{'one_vs_rest', 'one_vs_one'}",
            "optional": "False",
            "description": "Specifies how multi-class classification problems are handled.",
            "sklearn": {
              "default_value": "'one_vs_rest'",
              "path": "multi_class"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iter_predict",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of iterations in Newton\\u2019s method for approximating the posterior during predict. Smaller values will reduce computation time at the cost of worse results.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter_predict"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "partial least squares regression",
      "other_names": [
        "PLS Regession"
      ],
      "implementation": {
        "sklearn": "sklearn.cross_decomposition.pls_.PLSRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "sklearn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "sklearn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether the deflation should be done on a copy. Let the default value to True unless you don\\u2019t care about side effect.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "sklearn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "2 blocks canonical partial least squares",
      "other_names": [
        "PLS Canonical"
      ],
      "implementation": {
        "sklearn": "sklearn.cross_decomposition.pls_.PLSCanonical"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "sklearn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "weight_algorithm",
            "kind_of_value": "{'nipals', 'svd'}",
            "optional": "False",
            "description": "The algorithm used to estimate the weights.",
            "sklearn": {
              "default_value": "'nipals'",
              "path": "algorithm"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "sklearn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether the deflation should be done on a copy. Let the default value to True unless you don\\u2019t care about side effect.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "sklearn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "partial least squares singular value decomposition",
      "other_names": [
        "PLSSVD"
      ],
      "implementation": {
        "sklearn": "sklearn.cross_decomposition.pls_.PLSSVD"
      },
      "type": "Matrix Decomposition",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "sklearn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether the deflation should be done on a copy. Let the default value to True unless you don\\u2019t care about side effect.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "canonical correlation analysis",
      "other_names": [
        "CCA"
      ],
      "implementation": {
        "sklearn": "sklearn.cross_decomposition.cca_.CCA"
      },
      "type": "Matrix Decomposition",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of components to keep.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "scale",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to scale the data.",
            "sklearn": {
              "default_value": "True",
              "path": "scale"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "positive float",
            "optional": "False",
            "description": "Tolerance used in the iterative algorithm.",
            "sklearn": {
              "default_value": "0.000006",
              "path": "tol"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether the deflation should be done on a copy. Let the default value to True unless you don\\u2019t care about side effect.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The maximum number of iterations of the NIPALS inner loop.",
            "sklearn": {
              "default_value": "500",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gaussian naive bayes",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.naive_bayes.GaussianNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes,)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "sklearn": {
              "default_value": "None",
              "path": "priors"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multinomial naive bayes classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.naive_bayes.MultinomialNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "smoothing parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Additive (Laplace/Lidstone) smoothing parameter.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "learn_prior_probabilities",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to learn class prior probabilities or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_prior"
            }
          },
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes,)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "sklearn": {
              "default_value": "None",
              "path": "class_prior"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "bernoulli naive bayes classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.naive_bayes.BernoulliNB"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "smoothing parameter",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Additive (Laplace/Lidstone) smoothing parameter.",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "binarizeing_threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Threshold for binarizing (mapping to booleans) of sample features.",
            "sklearn": {
              "default_value": "0.0",
              "path": "binarize"
            }
          },
          {
            "name": "learn_prior_probabilities",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to learn class prior probabilities or not.",
            "sklearn": {
              "default_value": "True",
              "path": "fit_prior"
            }
          },
          {
            "name": "class_priors",
            "kind_of_value": "array-like, shape (n_classes,)",
            "optional": "False",
            "description": "Prior probabilities of the classes. If specified the priors are not adjusted according to the data.",
            "sklearn": {
              "default_value": "None",
              "path": "class_prior"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "decision tree classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.tree.tree.DecisionTreeClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "splitting_strategy",
            "kind_of_value": "{'best', 'random'}",
            "optional": "True",
            "description": "The strategy used to choose the split at each node.",
            "sklearn": {
              "default_value": "'best'",
              "path": "splitter"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, list of dicts, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "presort",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "presort"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "decision tree regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.tree.tree.DecisionTreeRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "splitting_strategy",
            "kind_of_value": "{'best', 'random'}",
            "optional": "True",
            "description": "The strategy used to choose the split at each node.",
            "sklearn": {
              "default_value": "'best'",
              "path": "splitter"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0",
              "path": "min_impurity_decrease"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "presort",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "sklearn": {
              "default_value": "False",
              "path": "presort"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "extra-trees regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.forest.ExtraTreesRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "sklearn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "sklearn": {
              "default_value": "False",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the R^2 on unseen data.",
            "sklearn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "extra-trees classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.forest.ExtraTreesClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "sklearn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "sklearn": {
              "default_value": "False",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization accuracy.",
            "sklearn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', 'balanced_subsample', None}",
            "optional": "True",
            "description": "Weights associated with classes.",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random forest regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.forest.RandomForestRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "sklearn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'mse'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "sklearn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use out-of-bag samples to estimate the R^2 on unseen data.",
            "sklearn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "random forest classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.forest.RandomForestClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "sklearn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'gini', 'entropy'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'gini'",
              "path": "criterion"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "max_features"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "sklearn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization accuracy.",
            "sklearn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "class_weight",
            "kind_of_value": "{dict, 'balanced', None}",
            "optional": "False",
            "description": "Weights associated with classes.",
            "sklearn": {
              "default_value": "None",
              "path": "class_weight"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bagging classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.bagging.BaggingClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "The base estimator to fit on random subsets of the dataset.",
            "sklearn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "sklearn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_samples",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of samples to draw from X to train each base estimator.",
            "sklearn": {
              "default_value": "1.0",
              "path": "max_samples"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of features to draw from X to train each base estimator.",
            "sklearn": {
              "default_value": "1.0",
              "path": "max_features"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether samples are drawn with replacement.",
            "sklearn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "bootstrap_features",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether features are drawn with replacement.",
            "sklearn": {
              "default_value": "False",
              "path": "bootstrap_features"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization error.",
            "sklearn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "bagging regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.bagging.BaggingRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "The base estimator to fit on random subsets of the dataset.",
            "sklearn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "sklearn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_samples",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of samples to draw from X to train each base estimator.",
            "sklearn": {
              "default_value": "1.0",
              "path": "max_samples"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of features to draw from X to train each base estimator.",
            "sklearn": {
              "default_value": "1.0",
              "path": "max_features"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether samples are drawn with replacement.",
            "sklearn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "bootstrap_features",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether features are drawn with replacement.",
            "sklearn": {
              "default_value": "False",
              "path": "bootstrap_features"
            }
          },
          {
            "name": "oob_samples",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use out-of-bag samples to estimate the generalization error.",
            "sklearn": {
              "default_value": "False",
              "path": "oob_score"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "voting classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.VotingClassifier"
      },
      "type": "Classifcation",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimators",
            "kind_of_value": "string, estimator tuple{('lr', clf1), ('rf', clf2), ('gnb', clf3), ('dt', clf1), ('knn', clf2), ('svc', clf3)}",
            "optional": "False",
            "description": "Used estimators.",
            "sklearn": {
              "default_value": "",
              "path": "estimators"
            }
          },
          {
            "name": "voting",
            "kind_of_value": "{'hard', 'soft'}",
            "optional": "False",
            "description": "If 'hard', uses predicted class labels for majority rule voting. Else if 'soft', predicts the class label based on the argmax of the sums of the predicted probabilities, which is recommended for an ensemble of well-calibrated classifiers.",
            "sklearn": {
              "default_value": "'hard'",
              "path": "voting"
            }
          },
          {
            "name": "weights",
            "kind_of_value": "array-like, shape = [n_classifiers] integer, float, None",
            "optional": "True",
            "description": "Sequence of weights (float or int) to weight the occurrences of predicted class labels (hard voting) or class probabilities before averaging (soft voting). Uses uniform weights if None.",
            "sklearn": {
              "default_value": "None",
              "path": "weights"
            }
          },
          {
            "name": "flatten_transform",
            "kind_of_value": "{boolean, None}",
            "optional": "True",
            "description": "Affects shape of transform output only when voting='soft'.",
            "sklearn": {
              "default_value": "None",
              "path": "flatten_transform"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gradient boosting for regression",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.gradient_boosting.GradientBoostingRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss",
            "kind_of_value": "{'ls', 'lad', 'huber', 'quantile'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "sklearn": {
              "default_value": "'ls'",
              "path": "loss"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "learning rate shrinks the contribution of each tree by learning_rate.",
            "sklearn": {
              "default_value": "0.1",
              "path": "learning_rate"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.",
            "sklearn": {
              "default_value": "100",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.",
            "sklearn": {
              "default_value": "3",
              "path": "max_depth"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'friedman_mse'",
              "path": "criterion"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "frac_subsample",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The fraction of samples to be used for fitting the individual base learners.",
            "sklearn": {
              "default_value": "1.0",
              "path": "subsample"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer, None",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "alpha_quantile",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The alpha-quantile of the huber loss function and the quantile loss function. ",
            "sklearn": {
              "default_value": "0.9",
              "path": "alpha"
            }
          },
          {
            "name": "init_estimator",
            "kind_of_value": "BaseEstimator, None",
            "optional": "True",
            "description": "An estimator object that is used to compute the initial predictions.",
            "sklearn": {
              "default_value": "None",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "presort",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "presort"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "gradient boosting for classification",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.gradient_boosting.GradientBoostingClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "loss",
            "kind_of_value": "{'deviance', 'exponential'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "sklearn": {
              "default_value": "'deviance'",
              "path": "loss"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "learning rate shrinks the contribution of each tree by learning_rate.",
            "sklearn": {
              "default_value": "0.1",
              "path": "learning_rate"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.",
            "sklearn": {
              "default_value": "100",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.",
            "sklearn": {
              "default_value": "3",
              "path": "max_depth"
            }
          },
          {
            "name": "split_quality",
            "kind_of_value": "{'mse', 'friedman_mse', 'mae'}",
            "optional": "True",
            "description": "The function to measure the quality of a split.",
            "sklearn": {
              "default_value": "'friedman_mse'",
              "path": "criterion"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "frac_subsample",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The fraction of samples to be used for fitting the individual base learners.",
            "sklearn": {
              "default_value": "1.0",
              "path": "subsample"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float, 'auto', 'sqrt', 'log2', None}",
            "optional": "True",
            "description": "The number of features to consider when looking for the best split.",
            "sklearn": {
              "default_value": "None",
              "path": "max_features"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "integer, None",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "init_estimator",
            "kind_of_value": "BaseEstimator, None",
            "optional": "True",
            "description": "An estimator object that is used to compute the initial predictions.",
            "sklearn": {
              "default_value": "None",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "presort",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Whether to presort the data to speed up the finding of best splits in fitting.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "presort"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "AdaBoost regressor",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.weight_boosting.AdaBoostRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "sklearn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of estimators at which boosting is terminated. In case of perfect fit, the learning procedure is stopped early.",
            "sklearn": {
              "default_value": "50",
              "path": "n_estimators"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Learning rate shrinks the contribution of each regressor by learning_rate.",
            "sklearn": {
              "default_value": "1.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "loss",
            "kind_of_value": "{'linear', 'square', 'exponential'}",
            "optional": "True",
            "description": "Loss function to be optimized.",
            "sklearn": {
              "default_value": "'linear'",
              "path": "loss"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "AdaBoost classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.weight_boosting.AdaBoostClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "True",
            "description": "base_estimator.",
            "sklearn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The maximum number of estimators at which boosting is terminated. In case of perfect fit, the learning procedure is stopped early.",
            "sklearn": {
              "default_value": "50",
              "path": "n_estimators"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Learning rate shrinks the contribution of each regressor by learning_rate.",
            "sklearn": {
              "default_value": "1.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "boosting_algorithm",
            "kind_of_value": " {'SAMME', 'SAMME.R'}",
            "optional": "True",
            "description": "If \\u2018SAMME.R\\u2019 then use the SAMME.R real boosting algorithm. base_estimator must support calculation of class probabilities. If \\u2018SAMME\\u2019 then use the SAMME discrete boosting algorithm. The SAMME.R algorithm typically converges faster than SAMME, achieving a lower test error with fewer boosting iterations.",
            "sklearn": {
              "default_value": "'SAMME.R'",
              "path": "algorithm"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "random trees ensemble",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.forest.RandomTreesEmbedding"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of trees in the forest.",
            "sklearn": {
              "default_value": "10",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_depth_tree",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The maximum depth of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "max_depth"
            }
          },
          {
            "name": "min_samples_split",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to split an internal node.",
            "sklearn": {
              "default_value": "2",
              "path": "min_samples_split"
            }
          },
          {
            "name": "min_samples_leaf",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The minimum number of samples required to be at a leaf node.",
            "sklearn": {
              "default_value": "1",
              "path": "min_samples_leaf"
            }
          },
          {
            "name": "min_weight_fraction_leaf",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_weight_fraction_leaf"
            }
          },
          {
            "name": "max_leaf_nodes",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Grow a tree with max_leaf_nodes in best-first fashion.",
            "sklearn": {
              "default_value": "None",
              "path": "max_leaf_nodes"
            }
          },
          {
            "name": "min_impurity_decrease",
            "kind_of_value": "float",
            "optional": "True",
            "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
            "sklearn": {
              "default_value": "0.0",
              "path": "min_impurity_decrease"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether bootstrap samples are used when building trees.",
            "sklearn": {
              "default_value": "True",
              "path": "bootstrap"
            }
          },
          {
            "name": "sparse_output",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether or not to return a sparse CSR matrix, as default behavior, or to return a dense array compatible with dense pipeline operators.",
            "sklearn": {
              "default_value": "True",
              "path": "sparse_output"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "classifier chain",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.multioutput.ClassifierChain"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "estimator",
            "optional": "False",
            "description": "The base estimator from which the classifier chain is built.",
            "sklearn": {
              "default_value": "",
              "path": "base_estimator"
            }
          },
          {
            "name": "prediction_order",
            "kind_of_value": "{array-like, shape=[n_outputs], 'random', None}",
            "optional": "True",
            "description": "Order in which the chain makes predictions about the columns in the label matrix Y.",
            "sklearn": {
              "default_value": "None",
              "path": "order"
            }
          },
          {
            "name": "cross_validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train and test splits, None",
            "optional": "True",
            "description": "Determines the cross-validation splitting strategy.",
            "sklearn": {
              "default_value": "None",
              "path": "cv"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multi target regression",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.multioutput.MultiOutputRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and predict.",
            "sklearn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "output code classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.multiclass.OutputCodeClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "sklearn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "code_size",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Percentage of the number of classes to be used to create the code book. A number between 0 and 1 will require fewer classifiers than one-vs-the-rest. A number greater than 1 will require more classifiers than one-vs-the-rest.",
            "sklearn": {
              "default_value": "1.5",
              "path": "code_size"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one vs one classifier",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.multiclass.OneVsOneClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "sklearn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "one vs rest classifier",
      "other_names": [
        "one vs all classifier"
      ],
      "implementation": {
        "sklearn": "sklearn.multiclass.OneVsRestClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "An estimator object implementing fit and either predict or decision.",
            "sklearn": {
              "default_value": "",
              "path": "estimator"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "select from model",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.feature_selection.SelectFromModel"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "sklearn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "threshold",
            "kind_of_value": "{'median', 'mean', float, None}",
            "optional": "True",
            "description": "The threshold value to use for feature selection.",
            "sklearn": {
              "default_value": "None",
              "path": "threshold"
            }
          },
          {
            "name": "prefit_model",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether a prefit model is expected to be passed into the constructor directly or not.",
            "sklearn": {
              "default_value": "False",
              "path": "prefit"
            }
          },
          {
            "name": "norm_order",
            "kind_of_value": "non-zero integer",
            "optional": "False",
            "description": "Order of the norm used to filter the vectors of coefficients below threshold in the case where the coef_ attribute of the estimator is of dimension 2.",
            "sklearn": {
              "default_value": "1",
              "path": "norm_order"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "recursive feature elimination with cross-validation",
      "other_names": [
        "RFECV"
      ],
      "implementation": {
        "sklearn": "sklearn.feature_selection.RFECV"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "The base estimator from which the transformer is built.",
            "sklearn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "step",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "If greater than or equal to 1, then step corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then step corresponds to the percentage (rounded down) of features to remove at each iteration.",
            "sklearn": {
              "default_value": "1",
              "path": "step"
            }
          },
          {
            "name": "cross_validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train and test splits, None",
            "optional": "True",
            "description": "Determines the cross-validation splitting strategy.",
            "sklearn": {
              "default_value": "None",
              "path": "cv"
            }
          },
          {
            "name": "scoring",
            "kind_of_value": "{callable, None, 'accuracy', 'average_precision', 'f1', 'f1_micro', 'f1_macro', 'f1_weighted', 'f1_samples', 'neg_log_loss', 'precision', 'recall', 'roc_auc', 'adjusted_mutual_info_score', 'adjusted_rand_score', 'completeness_score', 'fowlkes_mallows_score', 'homogeneity_score', 'mutual_info_score', 'normalized_mutual_info_score', 'v_measure_score', 'explained_variance', 'neg_mean_absolute_error', '\\u2018neg_mean_squared_error', 'neg_mean_squared_log_error', 'neg_median_absolute_error', 'r2'}",
            "optional": "True",
            "description": "Scoring parameter that is applied to the evaluated estimator.",
            "sklearn": {
              "default_value": "None",
              "path": "scoring"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Controls verbosity of output.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "recursive feature elimination",
      "other_names": [
        "RFE"
      ],
      "implementation": {
        "sklearn": "sklearn.feature_selection.RFE"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "estimator",
            "kind_of_value": "estimator object",
            "optional": "False",
            "description": "A supervised learning estimator with a fit method that provides information about feature importance either through a coef_ attribute or through a feature_importances_ attribute.",
            "sklearn": {
              "default_value": "",
              "path": "estimator"
            }
          },
          {
            "name": "n_features_to_select",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "The number of features to select. If None, half of the features are selected.",
            "sklearn": {
              "default_value": "None",
              "path": "n_features_to_select"
            }
          },
          {
            "name": "step",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "If greater than or equal to 1, then step corresponds to the (integer) number of features to remove at each iteration. If within (0.0, 1.0), then step corresponds to the percentage (rounded down) of features to remove at each iteration.",
            "sklearn": {
              "default_value": "1",
              "path": "step"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Controls verbosity of output.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "univariate feature selector",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.feature_selection.univariate_selection.GenericUnivariateSelect"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "sklearn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "mode",
            "kind_of_value": " {'percentile', 'k_best', 'fpr', 'fdr', 'fwe'}",
            "optional": "False",
            "description": "Feature selection mode.",
            "sklearn": {
              "default_value": "'percentile'",
              "path": "mode"
            }
          },
          {
            "name": "mode_parameter",
            "kind_of_value": "{float, integer}",
            "optional": "False",
            "description": "Parameter of the corresponding mode.",
            "sklearn": {
              "default_value": "0,00001",
              "path": "param"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select familiy-wise error rate",
      "other_names": [
        "select Fwe"
      ],
      "implementation": {
        "sklearn": "sklearn.feature_selection.univariate_selection.SelectFwe"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "sklearn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "sklearn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select estimated false discovery rate",
      "other_names": [
        "select Fdr"
      ],
      "implementation": {
        "sklearn": "sklearn.feature_selection.univariate_selection.SelectFdr"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "sklearn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "sklearn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select below false positive rate",
      "other_names": [
        "select Fpr"
      ],
      "implementation": {
        "sklearn": "sklearn.feature_selection.univariate_selection.SelectFpr"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "sklearn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "max_uncorrected_p-value",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The highest uncorrected p-value for features to keep.",
            "sklearn": {
              "default_value": "0.05",
              "path": "alpha"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select percentile",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.feature_selection.univariate_selection.SelectPercentile"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "sklearn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "percentile",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Percent of features to keep.",
            "sklearn": {
              "default_value": "10",
              "path": "percentile"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "select k best",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.feature_selection.univariate_selection.SelectKBest"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "score_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "Function taking two arrays X and y, and returning a pair of arrays (scores, pvalues). ",
            "sklearn": {
              "default_value": "<function f_classif>",
              "path": "score_func"
            }
          },
          {
            "name": "k",
            "kind_of_value": "{integer, 'all'}",
            "optional": "True",
            "description": "Number of top features to select.",
            "sklearn": {
              "default_value": "10",
              "path": "k"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "variance threshold",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.feature_selection.variance_threshold.VarianceThreshold"
      },
      "type": "Feature Selection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "threshold",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Features with a training-set variance lower than this threshold will be removed.",
            "sklearn": {
              "default_value": "0.0",
              "path": "threshold"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "label propagation",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.semi_supervised.label_propagation.LabelPropagation"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "{'knn', 'rbf', a callable taking two inputs in shape (n_samples, n_features) and returns weight matrix in shape [n_samples, n_samples]}",
            "optional": "False",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "rbf_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Parameter for rbf kernel",
            "sklearn": {
              "default_value": "20",
              "path": "gamma"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer > 0",
            "optional": "True",
            "description": "Number of neighbors to use by for knn kernel.",
            "sklearn": {
              "default_value": "7",
              "path": "n_neighbors"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Convergence tolerance: threshold to consider the system at steady state",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "label spreading",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.semi_supervised.label_propagation.LabelSpreading"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "kernel",
            "kind_of_value": "{'knn', 'rbf', a callable taking two inputs in shape (n_samples, n_features) and returns weight matrix in shape [n_samples, n_samples]}",
            "optional": "False",
            "description": "Specifies the kernel type to be used in the algorithm.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "kernel"
            }
          },
          {
            "name": "rbf_parameter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Parameter for rbf kernel",
            "sklearn": {
              "default_value": "20",
              "path": "gamma"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer > 0",
            "optional": "True",
            "description": "Number of neighbors to use by for knn kernel.",
            "sklearn": {
              "default_value": "7",
              "path": "n_neighbors"
            }
          },
          {
            "name": "calmping_factor",
            "kind_of_value": "float in [0,1]",
            "optional": "False",
            "description": "Clamping factor. A value in [0, 1] that specifies the relative amount that an instance should adopt the information from its neighbors as opposed to its initial label. 0 means  keeping the initial label information; 1 means replacing all initial information.",
            "sklearn": {
              "default_value": "0.2",
              "path": "alpha"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Convergence tolerance: threshold to consider the system at steady state",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "30",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "isotonic regression",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.isotonic.IsotonicRegression"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "min_fit",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "If not None, set the lowest value of the fit to min_fit",
            "sklearn": {
              "default_value": "None",
              "path": "y_min"
            }
          },
          {
            "name": "max_fit",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "If not None, set the highest value of the fit to max_fit",
            "sklearn": {
              "default_value": "None",
              "path": "y_max"
            }
          },
          {
            "name": "increasing",
            "kind_of_value": "{'auto', boolean}",
            "optional": "True",
            "description": "If boolean, whether or not to fit the isotonic regression with outputs increasing or decreasing. The string value \\u201cauto\\u201d determines whether outputs should increase or decrease based on the Spearman correlation estimate\\u2019s sign.",
            "sklearn": {
              "default_value": "True",
              "path": "increasing"
            }
          },
          {
            "name": "out_of_bounds",
            "kind_of_value": "{'nan, 'clip', 'raise'}",
            "optional": "True",
            "description": "Defines how input-values outside the training domain should be handled. 'nan' set predictions to NaN, 'clip' set predicted values to the value corresponding to the nearest train interval endpoint. 'raise' allows to throw a ValueError.",
            "sklearn": {
              "default_value": "'nan'",
              "path": "out_of_bounds"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "probability calibration with cross validation",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.calibration.CalibratedClassifierCV"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "base_estimator",
            "kind_of_value": "{object, None}",
            "optional": "False",
            "description": "The classifier whose output decision function needs to be calibrated to offer more accurate prediction probability outputs. ",
            "sklearn": {
              "default_value": "None",
              "path": "base_estimator"
            }
          },
          {
            "name": "calibration_method",
            "kind_of_value": "{'sigmoid', 'isotonic'}",
            "optional": "False",
            "description": "The method to use for calibration.",
            "sklearn": {
              "default_value": "'sigmoid'",
              "path": "method"
            }
          },
          {
            "name": "cross_validation",
            "kind_of_value": "{integer, object (cross-validation generator),  iterable yielding train and test splits, None, 'prefit'",
            "optional": "True",
            "description": "Determines the cross-validation splitting strategy.",
            "sklearn": {
              "default_value": "3",
              "path": "cv"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-layer perceptron regressor",
      "other_names": [
        "MLP regressor"
      ],
      "implementation": {
        "sklearn": "sklearn.neural_network.multilayer_perceptron.MLPRegressor"
      },
      "type": "Regression",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "hidden_layer_sizes",
            "kind_of_value": "tuple, length = n_layers - 2",
            "optional": "False",
            "description": "The ith element represents the number of neurons in the ith hidden layer.",
            "sklearn": {
              "default_value": "(100,)",
              "path": "hidden_layer_sizes"
            }
          },
          {
            "name": "activation",
            "kind_of_value": " {'identity', 'logistic', 'tanh', 'relu'}",
            "optional": "False",
            "description": "Activation function for the hidden layer.",
            "sklearn": {
              "default_value": "'relu'",
              "path": "activation"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'lbfgs', 'sgd', 'adam'}",
            "optional": "False",
            "description": "The solver for weight optimization.",
            "sklearn": {
              "default_value": "'adam'",
              "path": "solver"
            }
          },
          {
            "name": "l2_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "L2 penalty (regularization term) parameter.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "{integer, 'auto'}",
            "optional": "True",
            "description": "Size of minibatches for stochastic optimizers.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "batch_size"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'invscaling', 'adaptive'}",
            "optional": "False",
            "description": "Learning rate schedule for weight updates.",
            "sklearn": {
              "default_value": "'constant'",
              "path": "learning_rate"
            }
          },
          {
            "name": "learning_rate_init",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The initial learning rate used. It controls the step-size in updating the weights.",
            "sklearn": {
              "default_value": "0.001",
              "path": "learning_rate_init"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The exponent for inverse scaling learning rate.",
            "sklearn": {
              "default_value": "0.5",
              "path": "power_t"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle samples in each iteration.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to print progress messages to stdout.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "gradient_momentum",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Momentum for gradient descent update.",
            "sklearn": {
              "default_value": "0.9",
              "path": "momentum"
            }
          },
          {
            "name": "nesterovs_momentum",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use Nesterov\\u2019s momentum.",
            "sklearn": {
              "default_value": "True",
              "path": "nesterovs_momentum"
            }
          },
          {
            "name": "early_stopping",
            "kind_of_value": "boolean",
            "optional": "Flase",
            "description": "Whether to use early stopping to terminate training when validation score is not improving. If set to true, it will automatically set aside 10% of training data as validation and terminate training when validation score is not improving by at least tol for two consecutive epochs.",
            "sklearn": {
              "default_value": "Flase",
              "path": "early_stopping"
            }
          },
          {
            "name": "validation_fraction",
            "kind_of_value": "float between 0 and 1",
            "optional": "True",
            "description": "The proportion of training data to set aside as validation set for early stopping.",
            "sklearn": {
              "default_value": "0.1",
              "path": "validation_fraction"
            }
          },
          {
            "name": "adam_beta_1",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of first moment vector in adam.",
            "sklearn": {
              "default_value": "0.9",
              "path": "beta_1"
            }
          },
          {
            "name": "adam_beta_2",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of second moment vector in adam.",
            "sklearn": {
              "default_value": "0.999",
              "path": "beta_2"
            }
          },
          {
            "name": "adam_epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Value for numerical stability in adam.",
            "sklearn": {
              "default_value": "0.00000001",
              "path": "epsilon"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multi-layer perceptron classifier",
      "other_names": [
        "MLP classifier"
      ],
      "implementation": {
        "sklearn": "sklearn.neural_network.multilayer_perceptron.MLPClassifier"
      },
      "type": "Classification",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "hidden_layer_sizes",
            "kind_of_value": "tuple, length = n_layers - 2",
            "optional": "False",
            "description": "The ith element represents the number of neurons in the ith hidden layer.",
            "sklearn": {
              "default_value": "(100,)",
              "path": "hidden_layer_sizes"
            }
          },
          {
            "name": "activation",
            "kind_of_value": " {'identity', 'logistic', 'tanh', 'relu'}",
            "optional": "False",
            "description": "Activation function for the hidden layer.",
            "sklearn": {
              "default_value": "'relu'",
              "path": "activation"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'lbfgs', 'sgd', 'adam'}",
            "optional": "False",
            "description": "The solver for weight optimization.",
            "sklearn": {
              "default_value": "'adam'",
              "path": "solver"
            }
          },
          {
            "name": "l2_penalty",
            "kind_of_value": "float",
            "optional": "True",
            "description": "L2 penalty (regularization term) parameter.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "alpha"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "{integer, 'auto'}",
            "optional": "True",
            "description": "Size of minibatches for stochastic optimizers.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "batch_size"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "{'constant', 'invscaling', 'adaptive'}",
            "optional": "False",
            "description": "Learning rate schedule for weight updates.",
            "sklearn": {
              "default_value": "'constant'",
              "path": "learning_rate"
            }
          },
          {
            "name": "learning_rate_init",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The initial learning rate used. It controls the step-size in updating the weights.",
            "sklearn": {
              "default_value": "0.001",
              "path": "learning_rate_init"
            }
          },
          {
            "name": "inverse_scaling_exponent",
            "kind_of_value": "double",
            "optional": "True",
            "description": "The exponent for inverse scaling learning rate.",
            "sklearn": {
              "default_value": "0.5",
              "path": "power_t"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle samples in each iteration.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Precision of the solution. (The tolerance for the optimisation.)",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to print progress messages to stdout.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "gradient_momentum",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Momentum for gradient descent update.",
            "sklearn": {
              "default_value": "0.9",
              "path": "momentum"
            }
          },
          {
            "name": "nesterovs_momentum",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use Nesterov\\u2019s momentum.",
            "sklearn": {
              "default_value": "True",
              "path": "nesterovs_momentum"
            }
          },
          {
            "name": "early_stopping",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to use early stopping to terminate training when validation score is not improving. If set to true, it will automatically set aside 10% of training data as validation and terminate training when validation score is not improving by at least tol for two consecutive epochs.",
            "sklearn": {
              "default_value": "Flase",
              "path": "early_stopping"
            }
          },
          {
            "name": "validation_fraction",
            "kind_of_value": "float between 0 and 1",
            "optional": "True",
            "description": "The proportion of training data to set aside as validation set for early stopping.",
            "sklearn": {
              "default_value": "0.1",
              "path": "validation_fraction"
            }
          },
          {
            "name": "adam_beta_1",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of first moment vector in adam.",
            "sklearn": {
              "default_value": "0.9",
              "path": "beta_1"
            }
          },
          {
            "name": "adam_beta_2",
            "kind_of_value": "float should be in [0, 1)",
            "optional": "True",
            "description": "Exponential decay rate for estimates of second moment vector in adam.",
            "sklearn": {
              "default_value": "0.999",
              "path": "beta_2"
            }
          },
          {
            "name": "adam_epsilon",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Value for numerical stability in adam.",
            "sklearn": {
              "default_value": "0.00000001",
              "path": "epsilon"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "Gaussian mixture",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.mixture.gaussian_mixture.GaussianMixture"
      },
      "type": "Density Estimation",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of mixture components.",
            "sklearn": {
              "default_value": "1",
              "path": "n_components"
            }
          },
          {
            "name": "covariance_type",
            "kind_of_value": "{'full', 'tied', 'diag', 'spherical'}",
            "optional": "False",
            "description": "String describing the type of covariance parameters to use.",
            "sklearn": {
              "default_value": "'full'",
              "path": "covariance_type"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The convergence threshold.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "reg_covariance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Non-negative regularization added to the diagonal of covariance. Allows to assure that the covariance matrices are all positive.",
            "sklearn": {
              "default_value": "0.000001",
              "path": "reg_covar"
            }
          },
          {
            "name": "init_params",
            "kind_of_value": "{'kmeans', 'random'}",
            "optional": "False",
            "description": "The method used to initialize the weights, the means and the precisions.",
            "sklearn": {
              "default_value": "'kmeans'",
              "path": "init_params"
            }
          },
          {
            "name": "weights_init",
            "kind_of_value": "{array-like, shape (n_components, ), None}",
            "optional": "True",
            "description": "The user-provided initial weights.",
            "sklearn": {
              "default_value": "None",
              "path": "weights_init"
            }
          },
          {
            "name": "means_init",
            "kind_of_value": "{array-like, shape (n_components,  n_features), None}",
            "optional": "True",
            "description": "The user-provided initial means.",
            "sklearn": {
              "default_value": "None",
              "path": "means_init"
            }
          },
          {
            "name": "precisions_init",
            "kind_of_value": "{array-like depending on 'covariance_type': (n_components,) if 'spherical', (n_features, n_features) if 'tied', (n_components, n_features) if 'diag',(n_components, n_features, n_features) if 'full', None}",
            "optional": "True",
            "description": "The user-provided initial precisions (inverse of the covariance matrices).",
            "sklearn": {
              "default_value": "None",
              "path": "precisions_init"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Enable verbose output. If 1 then it prints the current initialization and each iteration step. If greater than 1 then it prints also the log probability and the time needed for each step.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "verbose_interval",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of iteration done before the next print.",
            "sklearn": {
              "default_value": "10",
              "path": "verbose_interval"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "num_initializations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of initializations to perform. The best results are kept.",
            "sklearn": {
              "default_value": "1",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "Bayesian Gaussian mixture",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.mixture.bayesian_mixture.BayesianGaussianMixture"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of mixture components.",
            "sklearn": {
              "default_value": "1",
              "path": "n_components"
            }
          },
          {
            "name": "covariance_type",
            "kind_of_value": "{'full', 'tied', 'diag', 'spherical'}",
            "optional": "False",
            "description": "String describing the type of covariance parameters to use.",
            "sklearn": {
              "default_value": "'full'",
              "path": "covariance_type"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The convergence threshold.",
            "sklearn": {
              "default_value": "0.001",
              "path": "tol"
            }
          },
          {
            "name": "reg_covariance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Non-negative regularization added to the diagonal of covariance. Allows to assure that the covariance matrices are all positive.",
            "sklearn": {
              "default_value": "0.000001",
              "path": "reg_covar"
            }
          },
          {
            "name": "init_params",
            "kind_of_value": "{'kmeans', 'random'}",
            "optional": "False",
            "description": "The method used to initialize the weights, the means and the precisions.",
            "sklearn": {
              "default_value": "'kmeans'",
              "path": "init_params"
            }
          },
          {
            "name": "weight_concentration_prior_type",
            "kind_of_value": "{'dirichlet_process', 'dirichlet_distribution'}",
            "optional": "False",
            "description": "String describing the type of the weight concentration prior.",
            "sklearn": {
              "default_value": "'dirichlet_process'",
              "path": "weight_concentration_prior_type"
            }
          },
          {
            "name": "weight_concentration_prior",
            "kind_of_value": "{float > 0, None}",
            "optional": "True",
            "description": "The dirichlet concentration of each component on the weight distribution (Dirichlet). This is commonly called gamma in the literature. The higher concentration puts more mass in the center and will lead to more components being active, while a lower concentration parameter will lead to more mass at the edge of the mixture weights simplex.",
            "sklearn": {
              "default_value": "None",
              "path": "weight_concentration_prior"
            }
          },
          {
            "name": "mean_precision_prior",
            "kind_of_value": "{float > 0, None}",
            "optional": "True",
            "description": "The precision prior on the mean distribution (Gaussian). Controls the extend to where means can be placed. Smaller values concentrate the means of each clusters around mean_prior.",
            "sklearn": {
              "default_value": "None",
              "path": "mean_precision_prior"
            }
          },
          {
            "name": "mean_prior",
            "kind_of_value": "{array-like, shape (n_features, ), None}",
            "optional": "True",
            "description": "The prior on the mean distribution (Gaussian).",
            "sklearn": {
              "default_value": "None",
              "path": "mean_prior"
            }
          },
          {
            "name": "degrees_of_freedom_prior",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "The prior of the number of degrees of freedom on the covariance distributions (Wishart). ",
            "sklearn": {
              "default_value": "None",
              "path": "degrees_of_freedom_prior"
            }
          },
          {
            "name": "covariance_prior",
            "kind_of_value": "{array-like depending on 'covariance_type': float if 'spherical', (n_features, n_features) if 'tied', (n_features, ) if 'diag',(n_features, n_features) if 'full', None}",
            "optional": "True",
            "description": "The user-provided initial precisions (inverse of the covariance matrices).",
            "sklearn": {
              "default_value": "None",
              "path": "covariance_prior"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "reuse_previous",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.",
            "sklearn": {
              "default_value": "False",
              "path": "warm_start"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Enable verbose output. If 1 then it prints the current initialization and each iteration step. If greater than 1 then it prints also the log probability and the time needed for each step.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "verbose_interval",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of iteration done before the next print.",
            "sklearn": {
              "default_value": "10",
              "path": "verbose_interval"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "num_initializations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of initializations to perform. The best results are kept.",
            "sklearn": {
              "default_value": "1",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "isomap embedding",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.manifold.isomap.Isomap"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of neighbors to consider for each point.",
            "sklearn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'auto', 'arpack', 'dense']",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "eigen_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance passed to the eigenvalue decomposition solver",
            "sklearn": {
              "default_value": "0",
              "path": "tol"
            }
          },
          {
            "name": "path_method",
            "kind_of_value": "{'auto', 'FW', 'D'}",
            "optional": "False",
            "description": "Method to use in finding shortest path. 'auto' : attempt to choose the best algorithm automatically. 'FW' : Floyd-Warshall algorithm. 'D' : Dijkstra\\u2019s algorithm.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "path_method"
            }
          },
          {
            "name": "neighbors_algorithm",
            "kind_of_value": "{'auto', 'brute', 'kd_tree', 'ball_tree'}",
            "optional": "False",
            "description": "Algorithm to use for nearest neighbors search, passed to neighbors. NearestNeighbors instance.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "neighbors_algorithm"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations for eigenvalue decomposition solver.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "locally linear embedding analysis",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.manifold.locally_linear_embedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "sample_data",
            "kind_of_value": "{array-like shape (n_samples, n_features), sparse matrix, BallTree, KDTree, NearestNeighbors}",
            "optional": "False",
            "description": "Sample data.",
            "sklearn": {
              "default_value": "",
              "path": "X"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of neighbors to consider for each point.",
            "sklearn": {
              "default_value": "",
              "path": "n_neighbors"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "sklearn": {
              "default_value": "",
              "path": "n_components"
            }
          },
          {
            "name": "regularization_constant",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization constant, multiplies the trace of the local covariance matrix of the distances.",
            "sklearn": {
              "default_value": "0.001",
              "path": "reg"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'auto', 'arpack', 'dense']",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "eigen_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance passed to the eigenvalue decomposition solver",
            "sklearn": {
              "default_value": "0.000001",
              "path": "tol"
            }
          },
          {
            "name": "embedding_method",
            "kind_of_value": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "optional": "False",
            "description": "Embedding method.",
            "sklearn": {
              "default_value": "'standard'",
              "path": "method"
            }
          },
          {
            "name": "hessian_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for Hessian eigenmapping method.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "hessian_tol"
            }
          },
          {
            "name": "modified_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for modified LLE method.",
            "sklearn": {
              "default_value": "0.000000000001",
              "path": "modified_tol"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations for eigenvalue decomposition solver.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "object oriented locally linear embedding analysis",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.manifold.locally_linear.LocallyLinearEmbedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of neighbors to consider for each point.",
            "sklearn": {
              "default_value": "5",
              "path": "n_neighbors"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "regularization_constant",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Regularization constant, multiplies the trace of the local covariance matrix of the distances.",
            "sklearn": {
              "default_value": "0.001",
              "path": "reg"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'auto', 'arpack', 'dense']",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "eigen_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance passed to the eigenvalue decomposition solver",
            "sklearn": {
              "default_value": "0.000001",
              "path": "tol"
            }
          },
          {
            "name": "embedding_method",
            "kind_of_value": "{'standard', 'hessian', 'modified', 'ltsa'}",
            "optional": "False",
            "description": "Embedding method.",
            "sklearn": {
              "default_value": "'standard'",
              "path": "method"
            }
          },
          {
            "name": "hessian_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for Hessian eigenmapping method.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "hessian_tol"
            }
          },
          {
            "name": "modified_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for modified LLE method.",
            "sklearn": {
              "default_value": "0.000000000001",
              "path": "modified_tol"
            }
          },
          {
            "name": "neighbors_algorithm",
            "kind_of_value": "{'auto', 'brute', 'kd_tree', 'ball_tree'}",
            "optional": "False",
            "description": "Algorithm to use for nearest neighbors search, passed to neighbors.NearestNeighbors instance.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "neighbors_algorithm"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations for eigenvalue decomposition solver.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "multidimensional scaling",
      "other_names": [
        "MDS"
      ],
      "implementation": {
        "sklearn": "sklearn.manifold.mds.MDS"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of coordinates for the manifold.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "metric_MDS",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, perform metric MDS; otherwise, perform nonmetric MDS.",
            "sklearn": {
              "default_value": "True",
              "path": "metric"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Level of verbosity.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Relative tolerance with respect to stress at which to declare convergence.",
            "sklearn": {
              "default_value": "0.001",
              "path": "eps"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "dissimilarity",
            "kind_of_value": "{'euclidean', 'precomputed'}",
            "optional": "True",
            "description": "Dissimilarity measure to use.",
            "sklearn": {
              "default_value": "'euclidean'",
              "path": "dissimilarity"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations of the SMACOF algorithm for a single run.",
            "sklearn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "num_initializations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of times the SMACOF algorithm will be run with different initializations. The final results will be the best output of the runs, determined by the run with the smallest final stress.",
            "sklearn": {
              "default_value": "4",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral embedding",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.manifold.spectral_embedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "adjacency_matrix",
            "kind_of_value": "array-like or sparse matrix, shape: (n_samples, n_samples)",
            "optional": "False",
            "description": "The adjacency matrix of the graph to embed.",
            "sklearn": {
              "default_value": "",
              "path": "adjacency"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "sklearn": {
              "default_value": "8",
              "path": "n_components"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'arpack', 'lobpcg', 'amg', None}",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "sklearn": {
              "default_value": "None",
              "path": "eigen_solver"
            }
          },
          {
            "name": "eigen_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.",
            "sklearn": {
              "default_value": "0.0",
              "path": "eigen_tol"
            }
          },
          {
            "name": "norm_laplacian",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, then compute normalized Laplacian.",
            "sklearn": {
              "default_value": "True",
              "path": "norm_laplacian"
            }
          },
          {
            "name": "drop_first",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to drop the first eigenvector. For spectral embedding, this should be True as the first eigenvector should be constant vector for connected graph, but for spectral clustering, this should be kept as False to retain the first eigenvector.",
            "sklearn": {
              "default_value": "True",
              "path": "drop_first"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "object oriented spectral embedding",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.manifold.spectral_embedding_.SpectralEmbedding"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "sklearn": {
              "default_value": "8",
              "path": "n_components"
            }
          },
          {
            "name": "affinity_matrix",
            "kind_of_value": "{'nearest_neighbors', 'rbf', 'precomputed', callable: use passed in function as affinity the function takes in data matrix (n_samples, n_features) and return affinity matrix (n_samples, n_samples)}",
            "optional": "False",
            "description": "How to construct the affinity matrix.",
            "sklearn": {
              "default_value": "'nearest_neighbors'",
              "path": "affinity"
            }
          },
          {
            "name": "gamma",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "Kernel coefficient for rbf kernel.",
            "sklearn": {
              "default_value": "None",
              "path": "gamma"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'arpack', 'lobpcg', 'amg', None}",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.",
            "sklearn": {
              "default_value": "None",
              "path": "eigen_solver"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of nearest neighbors for nearest_neighbors graph building.",
            "sklearn": {
              "default_value": "None",
              "path": "n_neighbors"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "t-distributed stochastic neighbor embedding",
      "other_names": [
        "TSNE",
        "t-SNE"
      ],
      "implementation": {
        "sklearn": "sklearn.manifold.t_sne.TSNE"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "perplexity",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE is quite insensitive to this parameter.",
            "sklearn": {
              "default_value": "30",
              "path": "perplexity"
            }
          },
          {
            "name": "early_exaggeration",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Controls how tight natural clusters in the original space are in the embedded space and how much space will be between them. For larger values, the space between natural clusters will be larger in the embedded space. Again, the choice of this parameter is not very critical. If the cost function increases during initial optimization, the early exaggeration factor or the learning rate might be too high.",
            "sklearn": {
              "default_value": "12.0",
              "path": "early_exaggeration"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The learning rate for t-SNE is usually in the range [10.0, 1000.0]. If the learning rate is too high, the data may look like a \\u2018ball\\u2019 with any point approximately equidistant from its nearest neighbours. If the learning rate is too low, most points may look compressed in a dense cloud with few outliers. If the cost function gets stuck in a bad local minimum increasing the learning rate may help.",
            "sklearn": {
              "default_value": "200.0",
              "path": "learning_rate"
            }
          },
          {
            "name": "min_grad_norm",
            "kind_of_value": "float",
            "optional": "True",
            "description": "If the gradient norm is below this threshold, the optimization will be stopped.",
            "sklearn": {
              "default_value": "0.0000001",
              "path": "min_grad_norm"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "sklearn": {
              "default_value": "'euclidean'",
              "path": "metric"
            }
          },
          {
            "name": "initialisation",
            "kind_of_value": "{'random', 'pca', numpy array of shape (n_samples, n_components)}",
            "optional": "True",
            "description": "Initialization of embedding.",
            "sklearn": {
              "default_value": "'random'",
              "path": "init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity level.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "optimisation_method",
            "kind_of_value": "{'barnes_hut', 'exact'}",
            "optional": "False",
            "description": "Gradient calculation algorithm optimisation.",
            "sklearn": {
              "default_value": "'barnes_hut'",
              "path": "method"
            }
          },
          {
            "name": "angle",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The angular size of a distant node as measured from a point. If this size is below 'angle' then it is used as a summary node of all points contained within it. This method is not very sensitive to changes in this parameter in the range of 0.2 - 0.8. Angle less than 0.2 has quickly increasing computation time and angle greater 0.8 has quickly increasing error.",
            "sklearn": {
              "default_value": "0.5",
              "path": "angle"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for the optimization.",
            "sklearn": {
              "default_value": "1000",
              "path": "n_iter"
            }
          },
          {
            "name": "max_iterations_without_progress",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations without progress before we abort the optimization, used after 250 initial iterations with early exaggeration. Note that progress is only checked every 50 iterations so this value is rounded to the next multiple of 50.",
            "sklearn": {
              "default_value": "300",
              "path": "n_iter_without_progress"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "k-means clustering",
      "other_names": [
        "Lloyd\\u2019s algorithm"
      ],
      "implementation": {
        "sklearn": "sklearn.cluster.k_means_.KMeans"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to form as well as the number of centroids to generate.",
            "sklearn": {
              "default_value": "8",
              "path": "n_clusters"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization.",
            "sklearn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Relative tolerance with regards to inertia to declare convergence",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Verbosity mode.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When pre-computing distances it is more numerically accurate to center the data first. If copy_x is True, then the original data is not modified. If False, the original data is modified, and put back before the function returns, but small numerical differences may be introduced by subtracting and then adding the data mean.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_x"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'auto', 'full', 'elkan'}",
            "optional": "False",
            "description": "K-means algorithm to use.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "sklearn": {
              "default_value": "10",
              "path": "n_init"
            }
          },
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of iterations of the k-means algorithm for a single run.",
            "sklearn": {
              "default_value": "300",
              "path": "max_iter"
            }
          },
          {
            "name": "precompute_distances",
            "kind_of_value": "{'auto', True, False}",
            "optional": "False",
            "description": "Precompute distances (faster but takes more memory). \\u2018auto\\u2019 : do not precompute distances if n_samples * n_clusters > 12 million. This corresponds to about 100MB overhead per job using double precision.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "precompute_distances"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "mini batch k-means clustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.k_means_.MiniBatchKMeans"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to form as well as the number of centroids to generate.",
            "sklearn": {
              "default_value": "8",
              "path": "n_clusters"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization.",
            "sklearn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Size of the mini batches.",
            "sklearn": {
              "default_value": "100",
              "path": "batch_size"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Verbosity mode.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "compute_labels",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Compute label assignment and inertia for the complete dataset once the minibatch optimization has converged in fit.",
            "sklearn": {
              "default_value": "True",
              "path": "compute_labels"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Control early stopping based on the relative center changes as measured by a smoothed, variance-normalized of the mean center squared position changes. This early stopping heuristics is closer to the one used for the batch variant of the algorithms but induces a slight computational and memory overhead over the inertia heuristic.",
            "sklearn": {
              "default_value": "0.0",
              "path": "tol"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics.",
            "sklearn": {
              "default_value": "100",
              "path": "max_iter"
            }
          },
          {
            "name": "max_no_improvement",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed inertia.",
            "sklearn": {
              "default_value": "10",
              "path": "max_no_improvement"
            }
          },
          {
            "name": "initialization_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of samples to randomly sample for speeding up the initialization (sometimes at the expense of accuracy).",
            "sklearn": {
              "default_value": "3*batch size",
              "path": "init_size"
            }
          },
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of random initializations that are tried.",
            "sklearn": {
              "default_value": "3",
              "path": "n_init"
            }
          },
          {
            "name": "reassignment_ratio",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Control the fraction of the maximum number of counts for a center to be reassigned. A higher value means that low count centers are more easily reassigned, which means that the model will take longer to converge, but should converge in a better clustering.",
            "sklearn": {
              "default_value": "0.01",
              "path": "reassignment_ratio"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "affinity propagation clustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.affinity_propagation_.AffinityPropagation"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "damping",
            "kind_of_value": "float (between 0.5 and 1)",
            "optional": "True",
            "description": "Damping factor is the extent to which the current value is maintained relative to incoming values (weighted 1 - damping). This in order to avoid numerical oscillations when updating these values (messages).",
            "sklearn": {
              "default_value": "0.5",
              "path": "damping"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Make a copy of input data.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          },
          {
            "name": "preference",
            "kind_of_value": "{array-like, shape (n_samples,), float, None}",
            "optional": "True",
            "description": "Preferences for each point - points with larger values of preferences are more likely to be chosen as exemplars. The number of exemplars, ie of clusters, is influenced by the input preferences value. If the preferences are not passed as arguments, they will be set to the median of the input similarities.",
            "sklearn": {
              "default_value": "None",
              "path": "preference"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'precomputed', 'euclidean'}'",
            "optional": "True",
            "description": "Which affinity to use.",
            "sklearn": {
              "default_value": "'euclidean'",
              "path": "affinity"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to be verbose.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics.",
            "sklearn": {
              "default_value": "200",
              "path": "max_iter"
            }
          },
          {
            "name": "convergence_iteration",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of iterations with no change in the number of estimated clusters that stops the convergence.",
            "sklearn": {
              "default_value": "15",
              "path": "convergence_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "mean shift clustering with flat kernel",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.mean_shift_.MeanShift"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "bandwidth",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "Bandwidth used in the RBF kernel.",
            "sklearn": {
              "default_value": "None",
              "path": "bandwidth"
            }
          },
          {
            "name": "seeds",
            "kind_of_value": "{array of shape=[n_samples, n_features], None}",
            "optional": "True",
            "description": "Seeds used to initialize kernels.",
            "sklearn": {
              "default_value": "None",
              "path": "seeds"
            }
          },
          {
            "name": "bin_seeding",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If true, initial kernel locations are not locations of all points, but rather the location of the discretized version of points, where points are binned onto a grid whose coarseness corresponds to the bandwidth. Setting this option to True will speed up the algorithm because fewer seeds will be initialized.",
            "sklearn": {
              "default_value": "False",
              "path": "bin_seeding"
            }
          },
          {
            "name": "min_bin_freq",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "To speed up the algorithm, accept only those bins with at least min_bin_freq points as seeds.",
            "sklearn": {
              "default_value": "1",
              "path": "min_bin_freq"
            }
          },
          {
            "name": "cluster_all",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If true, then all points are clustered, even those orphans that are not within any kernel. Orphans are assigned to the nearest kernel. If false, then orphans are given cluster label -1.",
            "sklearn": {
              "default_value": "True",
              "path": "cluster_all"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral clustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.spectral.SpectralClustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The dimension of the projection subspace.",
            "sklearn": {
              "default_value": "8",
              "path": "n_clusters"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'lobpcg', 'arpack', 'amg', None]",
            "optional": "False",
            "description": "The eigenvalue decomposition strategy to use.",
            "sklearn": {
              "default_value": "None",
              "path": "eigen_solver"
            }
          },
          {
            "name": "kernel_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels.",
            "sklearn": {
              "default_value": "10",
              "path": "gamma"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'nearest_neighbors', 'precomputed', 'rbf', 'sigmoid', 'polynomial', 'poly', 'linear', 'cosine', array-like, callable}'",
            "optional": "True",
            "description": "Which affinity to use.",
            "sklearn": {
              "default_value": "'rbf'",
              "path": "affinity"
            }
          },
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use when constructing the affinity matrix using the nearest neighbors method.",
            "sklearn": {
              "default_value": "10",
              "path": "n_neighbors"
            }
          },
          {
            "name": "eigen_tol",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stopping criterion for eigendecomposition of the Laplacian matrix.",
            "sklearn": {
              "default_value": "0.0",
              "path": "eigen_tol"
            }
          },
          {
            "name": "assign_labels",
            "kind_of_value": "{'kmeans', 'discretize'}",
            "optional": "False",
            "description": "The strategy to use to assign labels in the embedding space. There are two ways to assign labels after the laplacian embedding. k-means can be applied and is a popular choice. But it can also be sensitive to initialization. Discretization is another approach which is less sensitive to random initialization.",
            "sklearn": {
              "default_value": "'kmeans'",
              "path": "assign_labels"
            }
          },
          {
            "name": "kernel_degree",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Degree of the polynomial kernel.",
            "sklearn": {
              "default_value": "3.0",
              "path": "degree"
            }
          },
          {
            "name": "zero_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Zero coefficient for polynomial and sigmoid kernels.",
            "sklearn": {
              "default_value": "1.0",
              "path": "coef0"
            }
          },
          {
            "name": "kernel_parameters",
            "kind_of_value": "dictionary of string to any",
            "optional": "True",
            "description": "Additional parameters (keyword arguments) for kernel function passed as callable object.",
            "sklearn": {
              "default_value": "None",
              "path": "kernel_params"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          },
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "sklearn": {
              "default_value": "10",
              "path": "n_init"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "agglomerative clustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.hierarchical.AgglomerativeClustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to find.",
            "sklearn": {
              "default_value": "2",
              "path": "n_clusters"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'precomputed', 'euclidean', 'l1', 'l2', 'manhattan', 'cosine'}",
            "optional": "False",
            "description": "Which affinity to use.",
            "sklearn": {
              "default_value": "'euclidean'",
              "path": "affinity"
            }
          },
          {
            "name": "memory",
            "kind_of_value": "{None, object with the joblib.Memory interface, path to cashing directory}",
            "optional": "True",
            "description": "Used to cache the output of the computation of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "memory"
            }
          },
          {
            "name": "connectivity_matrix",
            "kind_of_value": "{array-like, callable, None}",
            "optional": "True",
            "description": "Connectivity matrix. Defines for each sample the neighboring samples following a given structure of the data. This can be a connectivity matrix itself or a callable that transforms the data into a connectivity matrix.",
            "sklearn": {
              "default_value": "None",
              "path": "connectivity"
            }
          },
          {
            "name": "compute_full_tree",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Stop early the construction of the tree at num_clusters. This is useful to decrease computation time if the number of clusters is not small compared to the number of samples. This option is useful only when specifying a connectivity matrix. Note also that when varying the number of clusters and using caching, it may be advantageous to compute the full tree.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "compute_full_tree"
            }
          },
          {
            "name": "linkage_criterion",
            "kind_of_value": "{'ward', 'complete', 'average'}",
            "optional": "True",
            "description": "Which linkage criterion to use. The linkage criterion determines which distance to use between sets of observation. The algorithm will merge the pairs of cluster that minimize this criterion.",
            "sklearn": {
              "default_value": "'ward'",
              "path": "linkage"
            }
          },
          {
            "name": "pooling_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "This combines the values of agglomerated features into a single value, and should accept an array of shape [M, N] and the keyword argument axis=1, and reduce it to an array of size [M].",
            "sklearn": {
              "default_value": "<function mean>",
              "path": "pooling_func"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "feature agglomerative clustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.hierarchical.FeatureAgglomeration"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of clusters to find.",
            "sklearn": {
              "default_value": "2",
              "path": "n_clusters"
            }
          },
          {
            "name": "affinity",
            "kind_of_value": "{'precomputed', 'euclidean', 'l1', 'l2', 'manhattan', 'cosine'}'",
            "optional": "False",
            "description": "Which affinity to use.",
            "sklearn": {
              "default_value": "'euclidean'",
              "path": "affinity"
            }
          },
          {
            "name": "memory",
            "kind_of_value": "{None, object with the joblib.Memory interface, path to cashing directory}",
            "optional": "True",
            "description": "Used to cache the output of the computation of the tree.",
            "sklearn": {
              "default_value": "None",
              "path": "memory"
            }
          },
          {
            "name": "connectivity_matrix",
            "kind_of_value": "{array-like, callable, None}",
            "optional": "True",
            "description": "Connectivity matrix. Defines for each sample the neighboring samples following a given structure of the data. This can be a connectivity matrix itself or a callable that transforms the data into a connectivity matrix.",
            "sklearn": {
              "default_value": "None",
              "path": "connectivity"
            }
          },
          {
            "name": "compute_full_tree",
            "kind_of_value": "{boolean, 'auto'}",
            "optional": "True",
            "description": "Stop early the construction of the tree at num_clusters. This is useful to decrease computation time if the number of clusters is not small compared to the number of samples. This option is useful only when specifying a connectivity matrix. Note also that when varying the number of clusters and using caching, it may be advantageous to compute the full tree.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "compute_full_tree"
            }
          },
          {
            "name": "linkage_criterion",
            "kind_of_value": "{'ward', 'complete', 'average'}",
            "optional": "True",
            "description": "Which linkage criterion to use. The linkage criterion determines which distance to use between sets of observation. The algorithm will merge the pairs of cluster that minimize this criterion.",
            "sklearn": {
              "default_value": "'ward'",
              "path": "linkage"
            }
          },
          {
            "name": "pooling_function",
            "kind_of_value": "callable",
            "optional": "False",
            "description": "This combines the values of agglomerated features into a single value, and should accept an array of shape [M, N] and the keyword argument axis=1, and reduce it to an array of size [M].",
            "sklearn": {
              "default_value": "<function mean>",
              "path": "pooling_func"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "DBSCAN",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.dbscan_.DBSCAN"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "eps",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The maximum distance between two samples for them to be considered as in the same neighborhood.",
            "sklearn": {
              "default_value": "0.5",
              "path": "eps"
            }
          },
          {
            "name": "min_samples",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of samples (or total weight) in a neighborhood for a point to be considered as a core point. This includes the point itself.",
            "sklearn": {
              "default_value": "5",
              "path": "min_samples"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "sklearn": {
              "default_value": "'euclidean'",
              "path": "metric"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "dict",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "The algorithm to be used by the NearestNeighbors module to compute pointwise distances and find nearest neighbors.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "The power of the Minkowski metric to be used to calculate distance between points.",
            "sklearn": {
              "default_value": "None",
              "path": "p"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "birch clustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.birch.Birch"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "threshold",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The radius of the subcluster obtained by merging a new sample and the closest subcluster should be lesser than the threshold. Otherwise a new subcluster is started. Setting this value to be very low promotes splitting and vice-versa.",
            "sklearn": {
              "default_value": "0.5",
              "path": "threshold"
            }
          },
          {
            "name": "branching_factor",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Maximum number of CF subclusters in each node. If a new samples enters such that the number of subclusters exceed the branching_factor then that node is split into two nodes with the subclusters redistributed in each. The parent subcluster of that node is removed and two new subclusters are added as parents of the 2 split nodes.",
            "sklearn": {
              "default_value": "50",
              "path": "branching_factor"
            }
          },
          {
            "name": "num_clusters",
            "kind_of_value": "{integer, instance of sklearn.cluster model, None}",
            "optional": "False",
            "description": "Number of clusters after the final clustering step, which treats the subclusters from the leaves as new samples.",
            "sklearn": {
              "default_value": "3",
              "path": "n_clusters"
            }
          },
          {
            "name": "compute_labels",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether or not to compute labels for each fit.",
            "sklearn": {
              "default_value": "True",
              "path": "compute_labels"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether or not to make a copy of the given data. If set to False, the initial data will be overwritten.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral co-clustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.bicluster.SpectralCoclustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of biclusters to find.",
            "sklearn": {
              "default_value": "3",
              "path": "n_clusters"
            }
          },
          {
            "name": "svd_method",
            "kind_of_value": "{'randomized', 'arpack'}",
            "optional": "True",
            "description": "Selects the algorithm for finding singular vectors.",
            "sklearn": {
              "default_value": "'randomized'",
              "path": "svd_method"
            }
          },
          {
            "name": "num_svd_vecs",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Number of vectors to use in calculating the SVD.",
            "sklearn": {
              "default_value": "None",
              "path": "n_svd_vecs"
            }
          },
          {
            "name": "mini_batch",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use mini-batch k-means, which is faster but may get different results.",
            "sklearn": {
              "default_value": "False",
              "path": "mini_batch"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization of k-means algorithm.",
            "sklearn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "sklearn": {
              "default_value": "10",
              "path": "n_init"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "spectral biclustering",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.cluster.bicluster.SpectralBiclustering"
      },
      "type": "Clustering",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_clusters",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of biclusters to find.",
            "sklearn": {
              "default_value": "3",
              "path": "n_clusters"
            }
          },
          {
            "name": "method",
            "kind_of_value": "{'scale', 'bistochastic', 'log'}",
            "optional": "True",
            "description": "Method of normalizing and converting singular vectors into biclusters.",
            "sklearn": {
              "default_value": "'bistochastic'",
              "path": "method"
            }
          },
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of singular vectors to check.",
            "sklearn": {
              "default_value": "6",
              "path": "n_components"
            }
          },
          {
            "name": "num_best",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of best singular vectors to which to project the data for clustering.",
            "sklearn": {
              "default_value": "3",
              "path": "n_best"
            }
          },
          {
            "name": "svd_method",
            "kind_of_value": "{'randomized', 'arpack'}",
            "optional": "True",
            "description": "Selects the algorithm for finding singular vectors.",
            "sklearn": {
              "default_value": "'randomized'",
              "path": "svd_method"
            }
          },
          {
            "name": "num_svd_vecs",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Number of vectors to use in calculating the SVD.",
            "sklearn": {
              "default_value": "None",
              "path": "n_svd_vecs"
            }
          },
          {
            "name": "mini_batch",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to use mini-batch k-means, which is faster but may get different results.",
            "sklearn": {
              "default_value": "False",
              "path": "mini_batch"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'k-means++', 'random',  array of shape (n_clusters, n_features)}",
            "optional": "False",
            "description": "Method for initialization of k-means algorithm.",
            "sklearn": {
              "default_value": "'k-means++'",
              "path": "init"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_initialization",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Number of time the k-means algorithm will be run with different centroid seeds.",
            "sklearn": {
              "default_value": "10",
              "path": "n_init"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "principal component analysis",
      "other_names": [
        "PCA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.pca.PCA"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, float, None, 'mle'}",
            "optional": "False",
            "description": "Number of components to keep.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If False, data passed to fit are overwritten and running fit(X).transform(X) will not yield the expected results, use fit_transform(X) instead.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          },
          {
            "name": "whiten",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When True (False by default) the components_ vectors are multiplied by the square root of n_samples and then divided by the singular values to ensure uncorrelated outputs with unit component-wise variances. Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometime improve the predictive accuracy of the downstream estimators by making their data respect some hard-wired assumptions.",
            "sklearn": {
              "default_value": "False",
              "path": "whiten"
            }
          },
          {
            "name": "svd_solver",
            "kind_of_value": " {'auto', 'full', 'arpack', 'randomized'}",
            "optional": "False",
            "description": "singular value decomposition solver",
            "sklearn": {
              "default_value": "'auto'",
              "path": "svd_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float >= 0",
            "optional": "False",
            "description": "Tolerance for singular values computed by svd_solver == 'arpack'.",
            "sklearn": {
              "default_value": "0.0",
              "path": "tol"
            }
          },
          {
            "name": "iterated_power",
            "kind_of_value": "{integer >= 0, 'auto'}",
            "optional": "False",
            "description": "Number of iterations for the power method computed by svd_solver == 'randomized'.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "iterated_power"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "incremental principal component analysis",
      "other_names": [
        "incremental PCA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.incremental_pca.IncrementalPCA"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of components to keep.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "whiten",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "When True (False by default) the components_ vectors are multiplied by the square root of n_samples and then divided by the singular values to ensure uncorrelated outputs with unit component-wise variances. Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometime improve the predictive accuracy of the downstream estimators by making their data respect some hard-wired assumptions.",
            "sklearn": {
              "default_value": "False",
              "path": "whiten"
            }
          },
          {
            "name": "copy",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If False, data passed to fit are overwritten and running fit(X).transform(X) will not yield the expected results, use fit_transform(X) instead.",
            "sklearn": {
              "default_value": "True",
              "path": "copy"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "The number of samples to use for each batch.",
            "sklearn": {
              "default_value": "None",
              "path": "batch_size"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "kernel principal component analysis",
      "other_names": [
        "kernel PCA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.kernel_pca.KernelPCA"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of components to keep.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'linear', 'poly', 'rbf', 'sigmoid', 'cosine', 'precomputed'}",
            "optional": "False",
            "description": "Kernel mapping used internally.",
            "sklearn": {
              "default_value": "'linear'",
              "path": "kernel"
            }
          },
          {
            "name": "gamma",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Gamma parameter for the RBF, polynomial and sigmoid kernels. Interpretation depends on kernels.",
            "sklearn": {
              "default_value": "None",
              "path": "gamma"
            }
          },
          {
            "name": "kernel_degree",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Degree of the polynomial kernel.",
            "sklearn": {
              "default_value": "3",
              "path": "degree"
            }
          },
          {
            "name": "zero_coefficient",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Zero coefficient for polynomial and sigmoid kernels.",
            "sklearn": {
              "default_value": "1.0",
              "path": "coef0"
            }
          },
          {
            "name": "kernel_parameters",
            "kind_of_value": "mapping of string to any",
            "optional": "False",
            "description": "Additional parameters (keyword arguments) for kernel function passed as callable object.",
            "sklearn": {
              "default_value": "None",
              "path": "kernel_params"
            }
          },
          {
            "name": "ridge_alpha",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Hyperparameter of the ridge regression that learns the inverse transform.",
            "sklearn": {
              "default_value": "1",
              "path": "alpha"
            }
          },
          {
            "name": "fit_inverse_transform",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Learn the inverse transform for non-precomputed kernels. (i.e. learn to find the pre-image of a point)",
            "sklearn": {
              "default_value": "False",
              "path": "fit_inverse_transform"
            }
          },
          {
            "name": "eigen_solver",
            "kind_of_value": "{'auto', 'arpack', 'dense']",
            "optional": "False",
            "description": "Solver for the eigenvalue decomposition.  If num_components is much less than the number of training samples, arpack may be more efficient than the dense eigensolver.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "eigen_solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Convergence tolerance for arpack. If 0, optimal value will be chosen by arpack.",
            "sklearn": {
              "default_value": "0.0",
              "path": "tol"
            }
          },
          {
            "name": "remove_zero_eigenvalue",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If True, then all components with zero eigenvalues are removed.",
            "sklearn": {
              "default_value": "False",
              "path": "remove_zero_eig"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "copy_X",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, input X is copied and stored by the model in the X_fit_ attribute. If no further changes will be done to X, setting copy_X=False saves memory by storing a reference.",
            "sklearn": {
              "default_value": "True",
              "path": "copy_X"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations for arpack. If None, optimal value will be chosen by arpack.",
            "sklearn": {
              "default_value": "None",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "sparse principal component analysis",
      "other_names": [
        "sparse PCA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.sparse_pca.SparsePCA"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of sparse atoms to extract.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "sparsity_parmeter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Sparsity controlling parameter. Higher values lead to sparser components.",
            "sklearn": {
              "default_value": "1",
              "path": "alpha"
            }
          },
          {
            "name": "ridge_alpha",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Amount of ridge shrinkage to apply in order to improve conditioning when calling the transform method.",
            "sklearn": {
              "default_value": "0.01",
              "path": "ridge_alpha"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance for the stopping condition.",
            "sklearn": {
              "default_value": "0.00000001",
              "path": "tol"
            }
          },
          {
            "name": "lasso_method",
            "kind_of_value": "{'lars', 'cd'}",
            "optional": "False",
            "description": "Embedding method.",
            "sklearn": {
              "default_value": "'lars'",
              "path": "method"
            }
          },
          {
            "name": "U_init",
            "kind_of_value": "array of shape (n_samples, n_components)",
            "optional": "False",
            "description": "Initial values for the loadings for warm restart scenarios.",
            "sklearn": {
              "default_value": "None",
              "path": "U_init"
            }
          },
          {
            "name": "V_init",
            "kind_of_value": "array of shape (n_components, n_features)",
            "optional": "False",
            "description": "Initial values for the components for warm restart scenarios.",
            "sklearn": {
              "default_value": "None",
              "path": "V_init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity; the higher, the more messages.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations to perform.",
            "sklearn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "mini batch sparse principal component analysis",
      "other_names": [
        "mini batch sparse PCA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.sparse_pca.MiniBatchSparsePCA"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of sparse atoms to extract.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "sparsity_parmeter",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Sparsity controlling parameter. Higher values lead to sparser components.",
            "sklearn": {
              "default_value": "1",
              "path": "alpha"
            }
          },
          {
            "name": "ridge_alpha",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Amount of ridge shrinkage to apply in order to improve conditioning when calling the transform method.",
            "sklearn": {
              "default_value": "0.01",
              "path": "ridge_alpha"
            }
          },
          {
            "name": "callback",
            "kind_of_value": "{callable, None}",
            "optional": "True",
            "description": "",
            "sklearn": {
              "default_value": "",
              "path": "callback"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of features to take in each mini batch.",
            "sklearn": {
              "default_value": "3",
              "path": "batch_size"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity; the higher, the more messages.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle the data before splitting it in batches.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "lasso_method",
            "kind_of_value": "{'lars', 'cd'}",
            "optional": "False",
            "description": "Embedding method.",
            "sklearn": {
              "default_value": "'lars'",
              "path": "method"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_iter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of iterations to perform for each mini batch.",
            "sklearn": {
              "default_value": "100",
              "path": "n_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "truncated single value decomposition",
      "other_names": [
        "truncated SVD",
        "LSA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.truncated_svd.TruncatedSVD"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of sparse atoms to extract.",
            "sklearn": {
              "default_value": "2",
              "path": "n_components"
            }
          },
          {
            "name": "svd_solver",
            "kind_of_value": " {'arpack', 'randomized'}",
            "optional": "False",
            "description": "singular value decomposition solver",
            "sklearn": {
              "default_value": "'randomized'",
              "path": "algorithm"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for ARPACK. 0 means machine precision. Ignored by randomized SVD solver.",
            "sklearn": {
              "default_value": "0.0",
              "path": "tol"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_iter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of iterations for randomized SVD solver. Not used by ARPACK. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
            "sklearn": {
              "default_value": "5",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "sparse coding",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.decomposition.SparseCoder"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "dictionary",
            "kind_of_value": "array of shape [n_components, n_features]",
            "optional": "False",
            "description": "The dictionary atoms used for sparse coding. Lines are assumed to be normalized to unit norm.",
            "sklearn": {
              "default_value": "",
              "path": "dictionary"
            }
          },
          {
            "name": "transform_algorithm",
            "kind_of_value": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "optional": "False",
            "description": "Algorithm used to transform the data.",
            "sklearn": {
              "default_value": "'omp'",
              "path": "transform_algorithm"
            }
          },
          {
            "name": "transform_num_nonzero_coefs",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of nonzero coefficients to target in each column of the solution.",
            "sklearn": {
              "default_value": "None",
              "path": "transform_n_nonzero_coefs"
            }
          },
          {
            "name": "l1_penalty",
            "kind_of_value": "{float, None}",
            "optional": "False",
            "description": "Penalty applied to the L1 norm.",
            "sklearn": {
              "default_value": "None",
              "path": "transform_alpha"
            }
          },
          {
            "name": "split_sign",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers.",
            "sklearn": {
              "default_value": "False",
              "path": "split_sign"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "dictionary learning",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.decomposition.dict_learning.DictionaryLearning"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of dictionary elements to extract.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "sparsity_control_param",
            "kind_of_value": "float",
            "optional": "False",
            "description": "sparsity controlling parameter",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance for numerical error.",
            "sklearn": {
              "default_value": "0.00000001",
              "path": "tol"
            }
          },
          {
            "name": "fit_algorithm",
            "kind_of_value": "{'lars', 'cd'}",
            "optional": "False",
            "description": "Method to solve the Lasso problem.",
            "sklearn": {
              "default_value": "",
              "path": "fit_algorithm"
            }
          },
          {
            "name": "transform_algorithm",
            "kind_of_value": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "optional": "False",
            "description": "Algorithm used to transform the data.",
            "sklearn": {
              "default_value": "'omp'",
              "path": "transform_algorithm"
            }
          },
          {
            "name": "transform_num_nonzero_coefs",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of nonzero coefficients to target in each column of the solution.",
            "sklearn": {
              "default_value": "None",
              "path": "transform_n_nonzero_coefs"
            }
          },
          {
            "name": "l1_penalty",
            "kind_of_value": "{float, None}",
            "optional": "False",
            "description": "Penalty applied to the L1 norm.",
            "sklearn": {
              "default_value": "None",
              "path": "transform_alpha"
            }
          },
          {
            "name": "code_init",
            "kind_of_value": "{array of shape (n_samples, n_components), None}",
            "optional": "False",
            "description": "Initial value for the code, for warm restart.",
            "sklearn": {
              "default_value": "None",
              "path": "code_init"
            }
          },
          {
            "name": "dict_init",
            "kind_of_value": "{array of shape (n_components, n_features), None}",
            "optional": "False",
            "description": "Initial value for the dictionary, for warm restart.",
            "sklearn": {
              "default_value": "None",
              "path": "dict_init"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "To control the verbosity of the procedure.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "split_sign",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers.",
            "sklearn": {
              "default_value": "False",
              "path": "split_sign"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "mini batch dictionary learning",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.decomposition.dict_learning.MiniBatchDictionaryLearning"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of dictionary elements to extract.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "sparsity_control_param",
            "kind_of_value": "float",
            "optional": "False",
            "description": "sparsity controlling parameter",
            "sklearn": {
              "default_value": "1.0",
              "path": "alpha"
            }
          },
          {
            "name": "fit_algorithm",
            "kind_of_value": "{'lars', 'cd'}",
            "optional": "False",
            "description": "Method to solve the Lasso problem.",
            "sklearn": {
              "default_value": "",
              "path": "fit_algorithm"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Size of minibatches for stochastic optimizers.",
            "sklearn": {
              "default_value": "3",
              "path": "batch_size"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Whether to shuffle the samples before forming batches.",
            "sklearn": {
              "default_value": "True",
              "path": "shuffle"
            }
          },
          {
            "name": "dict_init",
            "kind_of_value": "{array of shape (n_components, n_features), None}",
            "optional": "False",
            "description": "Initial value for the dictionary, for warm restart.",
            "sklearn": {
              "default_value": "None",
              "path": "dict_init"
            }
          },
          {
            "name": "transform_algorithm",
            "kind_of_value": "{'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}",
            "optional": "False",
            "description": "Algorithm used to transform the data.",
            "sklearn": {
              "default_value": "'omp'",
              "path": "transform_algorithm"
            }
          },
          {
            "name": "transform_num_nonzero_coefs",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Number of nonzero coefficients to target in each column of the solution.",
            "sklearn": {
              "default_value": "None",
              "path": "transform_n_nonzero_coefs"
            }
          },
          {
            "name": "l1_penalty",
            "kind_of_value": "{float, None}",
            "optional": "False",
            "description": "Penalty applied to the L1 norm.",
            "sklearn": {
              "default_value": "None",
              "path": "transform_alpha"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "To control the verbosity of the procedure.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "split_sign",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers.",
            "sklearn": {
              "default_value": "False",
              "path": "split_sign"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "1000",
              "path": "n_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "factor analysis",
      "other_names": [
        "FA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.factor_analysis.FactorAnalysis"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "False",
            "description": "Dimensionality of latent space, the number of components of X that are obtained after transform.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stopping tolerance for EM algorithm.",
            "sklearn": {
              "default_value": "0.01",
              "path": "tol"
            }
          },
          {
            "name": "noise_variance_init",
            "kind_of_value": "{array of shape (n_features,), None}",
            "optional": "False",
            "description": "The initial guess of the noise variance for each feature.",
            "sklearn": {
              "default_value": "None",
              "path": "noise_variance_init"
            }
          },
          {
            "name": "svd_method",
            "kind_of_value": "{'randomized', 'lapack'}",
            "optional": "False",
            "description": "Selects the algorithm for finding singular vectors.",
            "sklearn": {
              "default_value": "'randomized'",
              "path": "svd_method"
            }
          },
          {
            "name": "iterated_power",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of iterations for the power method computed by svd_solver == 'randomized'.",
            "sklearn": {
              "default_value": "3",
              "path": "iterated_power"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations.",
            "sklearn": {
              "default_value": "1000",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "fast independent component analysis",
      "other_names": [
        "fast ICA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.fastica_.FastICA"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Number of components to use. If none is passed, all are used.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'parallel', 'deflation'}",
            "optional": "False",
            "description": "Apply parallel or deflational algorithm for FastICA.",
            "sklearn": {
              "default_value": "'parallel'",
              "path": "algorithm"
            }
          },
          {
            "name": "whiten",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If whiten is false, the data is already considered to be whitened, and no whitening is performed.",
            "sklearn": {
              "default_value": "True",
              "path": "whiten"
            }
          },
          {
            "name": "functional_function_form",
            "kind_of_value": "{'logcosh', 'exp', 'cube', function that contains a tuple containing the value of the function, and of its derivative}",
            "optional": "True",
            "description": "The functional form of the G function used in the approximation to neg-entropy.",
            "sklearn": {
              "default_value": "'logcosh'",
              "path": "fun"
            }
          },
          {
            "name": "function_arguments",
            "kind_of_value": "{dictionary, None}",
            "optional": "True",
            "description": "Arguments to send to the functional form.",
            "sklearn": {
              "default_value": "None",
              "path": "fun_args"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Tolerance on update at each iteration.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "w_init",
            "kind_of_value": "{array of shape (n_components, n_components), None}",
            "optional": "False",
            "description": "The mixing matrix to be used to initialize the algorithm.",
            "sklearn": {
              "default_value": "None",
              "path": "w_init"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations during fit.",
            "sklearn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "non-negative matrix factorization",
      "other_names": [
        "NFM"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.nmf.NMF"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Number of components to use. If none is passed, all are used.",
            "sklearn": {
              "default_value": "None",
              "path": "n_components"
            }
          },
          {
            "name": "initialization_method",
            "kind_of_value": "{'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom', None}",
            "optional": "False",
            "description": "Method used to initialize the procedure.",
            "sklearn": {
              "default_value": "None",
              "path": "init"
            }
          },
          {
            "name": "solver",
            "kind_of_value": "{'cd', 'mu'}",
            "optional": "False",
            "description": "Numerical solver to use.",
            "sklearn": {
              "default_value": "'cd'",
              "path": "solver"
            }
          },
          {
            "name": "tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "Tolerance of the stopping condition.",
            "sklearn": {
              "default_value": "0.0001",
              "path": "tol"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "regularization_multiplier",
            "kind_of_value": "double",
            "optional": "False",
            "description": "Constant that multiplies the regularization terms. Set it to zero to have no regularization.",
            "sklearn": {
              "default_value": "0.0",
              "path": "alpha"
            }
          },
          {
            "name": "l1_ratio",
            "kind_of_value": "double",
            "optional": "False",
            "description": "The ElasticNet mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1_ratio = 1 it is an elementwise L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",
            "sklearn": {
              "default_value": "0.0",
              "path": "l1_ratio"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "Whether to be verbose.",
            "sklearn": {
              "default_value": "False",
              "path": "verbose"
            }
          },
          {
            "name": "shuffle",
            "kind_of_value": "boolean",
            "optional": "False",
            "description": "If true, randomize the order of coordinates in the CD solver.",
            "sklearn": {
              "default_value": "False",
              "path": "shuffle"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations during fit.",
            "sklearn": {
              "default_value": "200",
              "path": "max_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "latent Dirichlet allocation",
      "other_names": [
        "LDA"
      ],
      "implementation": {
        "sklearn": "sklearn.decomposition.online_lda.LatentDirichletAllocation"
      },
      "type": "Dimensionality Reduction",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of topics.",
            "sklearn": {
              "default_value": "10",
              "path": "n_components"
            }
          },
          {
            "name": "doc_topic_prior",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "Prior of document topic distribution theta. If the value is None, defaults to 1 / n_components. In the literature, this is called alpha.",
            "sklearn": {
              "default_value": "None",
              "path": "doc_topic_prior"
            }
          },
          {
            "name": "topic_word_prior",
            "kind_of_value": "{float, None}",
            "optional": "True",
            "description": "Prior of topic word distribution beta. If the value is None, defaults to 1 / n_components. In the literature, this is called eta.",
            "sklearn": {
              "default_value": "None",
              "path": "topic_word_prior"
            }
          },
          {
            "name": "learning_method",
            "kind_of_value": "{'batch', 'online'}",
            "optional": "False",
            "description": "Method used to update _component. Only used in fit method. In general, if the data size is large, the online update will be much faster than the batch update.",
            "sklearn": {
              "default_value": "'online'",
              "path": "learning_method"
            }
          },
          {
            "name": "learning_decay",
            "kind_of_value": "float between (0.5, 1.0]",
            "optional": "True",
            "description": "It is a parameter that control learning rate in the online learning method. The value should be set between (0.5, 1.0] to guarantee asymptotic convergence. When the value is 0.0 and batch_size is n_samples, the update method is same as batch learning. In the literature, this is called kappa.",
            "sklearn": {
              "default_value": "0.7",
              "path": "learning_decay"
            }
          },
          {
            "name": "learning_offset",
            "kind_of_value": "float > 0",
            "optional": "True",
            "description": "A (positive) parameter that downweights early iterations in online learning. It should be greater than 1.0. In the literature, this is called tau_0.",
            "sklearn": {
              "default_value": "10.",
              "path": "learning_offset"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of documents to use in each EM iteration. Only used in online learning.",
            "sklearn": {
              "default_value": "128",
              "path": "batch_size"
            }
          },
          {
            "name": "evaluate_every",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "How often to evaluate perplexity. Only used in fit method. set it to 0 or negative number to not evalute perplexity in training at all. Evaluating perplexity can help you check convergence in training process, but it will also increase total training time. Evaluating perplexity in every iteration might increase training time up to two-fold.",
            "sklearn": {
              "default_value": "0",
              "path": "evaluate_every"
            }
          },
          {
            "name": "total_samples",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Total number of documents. Only used in the partial_fit method.",
            "sklearn": {
              "default_value": "1000000",
              "path": "total_samples"
            }
          },
          {
            "name": "perplexity_tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Perplexity tolerance in batch learning.",
            "sklearn": {
              "default_value": "0.1",
              "path": "perp_tol"
            }
          },
          {
            "name": "mean_change_tolerance",
            "kind_of_value": "float",
            "optional": "True",
            "description": "Stopping tolerance for updating document topic distribution in E-step.",
            "sklearn": {
              "default_value": "0.001",
              "path": "mean_change_tol"
            }
          },
          {
            "name": "max_doc_update_iteration",
            "kind_of_value": "integer",
            "optional": "False",
            "description": "Max number of iterations for updating document topic distribution in the E-step.",
            "sklearn": {
              "default_value": "100",
              "path": "max_doc_update_iter"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity level.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "max_iterations",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Maximum number of iterations during fit.",
            "sklearn": {
              "default_value": "200",
              "path": "max_iter"
            }
          },
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use in the E-step. If -1, all CPUs are used. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "elliptice envelope",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.covariance.outlier_detection.EllipticEnvelope"
      },
      "type": "Outlier Detection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "store_precision",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "Specifies if the estimated precision is stored.",
            "sklearn": {
              "default_value": "True",
              "path": "store_precision"
            }
          },
          {
            "name": "assume_centered",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, the support of robust location and covariance estimates is computed, and a covariance estimate is recomputed from it, without centering the data. Useful to work with data whose mean is significantly equal to zero but is not exactly zero. If False, the robust location and covariance are directly computed with the FastMCD algorithm without additional treatment.",
            "sklearn": {
              "default_value": "False",
              "path": "assume_centered"
            }
          },
          {
            "name": "support_fraction",
            "kind_of_value": "{float in (0., 1.), None}",
            "optional": "True",
            "description": "The proportion of points to be included in the support of the raw MCD estimate. If None, the minimum value of support_fraction will be used within the algorithm: [n_sample + n_features + 1] / 2.",
            "sklearn": {
              "default_value": "None",
              "path": "support_fraction"
            }
          },
          {
            "name": "contamination",
            "kind_of_value": "float in (0., 0.5)",
            "optional": "True",
            "description": "The amount of contamination of the data set, i.e. the proportion of outliers in the data set.",
            "sklearn": {
              "default_value": "0.1",
              "path": "contamination"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "isolation forest",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.ensemble.iforest.IsolationForest"
      },
      "type": "Outlier Detection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_estimators",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of base estimators in the ensemble.",
            "sklearn": {
              "default_value": "100",
              "path": "n_estimators"
            }
          },
          {
            "name": "max_samples",
            "kind_of_value": "{integer, float, 'auto'}",
            "optional": "True",
            "description": "The number of samples to draw from X to train each base estimator.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "max_samples"
            }
          },
          {
            "name": "contamination",
            "kind_of_value": "float in (0., 0.5)",
            "optional": "True",
            "description": "The amount of contamination of the data set, i.e. the proportion of outliers in the data set.",
            "sklearn": {
              "default_value": "0.1",
              "path": "contamination"
            }
          },
          {
            "name": "max_features",
            "kind_of_value": "{integer, float}",
            "optional": "True",
            "description": "The number of features to draw from X to train each base estimator.",
            "sklearn": {
              "default_value": "1.0",
              "path": "max_features"
            }
          },
          {
            "name": "bootstrap",
            "kind_of_value": "boolean",
            "optional": "True",
            "description": "If True, individual trees are fit on random subsets of the training data sampled with replacement. If False, sampling without replacement is performed.",
            "sklearn": {
              "default_value": "False",
              "path": "bootstrap"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Controls the verbosity of the tree building process.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "local outlier factor",
      "other_names": [
        "LOF"
      ],
      "implementation": {
        "sklearn": "sklearn.neighbors.lof.LocalOutlierFactor"
      },
      "type": "Outlier Detection",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_neighbours",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of neighbors to use by default for kneighbors queries.",
            "sklearn": {
              "default_value": "20",
              "path": "n_neighbors"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree', 'brute'}",
            "optional": "True",
            "description": "The algorithm to be used by the NearestNeighbors module to compute pointwise distances and find nearest neighbors.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "30",
              "path": "leaf_size"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The metric to use when calculating distance between instances in a feature array.",
            "sklearn": {
              "default_value": "'minkowski'",
              "path": "metric"
            }
          },
          {
            "name": "minkowski_parameter",
            "kind_of_value": "{integer, None}",
            "optional": "True",
            "description": "Parameter for the Minkowski metric. When minkowski_parameter = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for minkowski_parameter = 2. For arbitrary minkowski_parameter, minkowski_distance (l_p) is used.",
            "sklearn": {
              "default_value": "2",
              "path": "p"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "{dict, None}",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          },
          {
            "name": "contamination",
            "kind_of_value": "float in (0., 0.5)",
            "optional": "True",
            "description": "The amount of contamination of the data set, i.e. the proportion of outliers in the data set.",
            "sklearn": {
              "default_value": "0.1",
              "path": "contamination"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "jobs",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "The number of jobs to use for the computation. If -1 all CPUs are used.",
            "sklearn": {
              "default_value": "1",
              "path": "n_jobs"
            }
          }
        ],
        "execution_parameters": []
      }
    },
    {
      "name": "kernel density",
      "other_names": [],
      "implementation": {
        "sklearn": "sklearn.neighbors.kde.KernelDensity"
      },
      "type": "Density Estimation",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "bandwidth",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The bandwidth of the kernel.",
            "sklearn": {
              "default_value": "1.0",
              "path": "bandwidth"
            }
          },
          {
            "name": "algorithm",
            "kind_of_value": "{'auto', 'ball_tree', 'kd_tree'}",
            "optional": "True",
            "description": "The tree algorithm to use.",
            "sklearn": {
              "default_value": "'auto'",
              "path": "algorithm"
            }
          },
          {
            "name": "kernel",
            "kind_of_value": "{'gaussian', 'tophat', 'epanechnikov', 'exponential', 'linear', 'cosine'}",
            "optional": "False",
            "description": "The kernel to use.",
            "sklearn": {
              "default_value": "'gaussian'",
              "path": "kernel"
            }
          },
          {
            "name": "distance_metric",
            "kind_of_value": "{'cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan', 'braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule', a callable that should take two arrays as input and return one value indicating the distance between them}",
            "optional": "False",
            "description": "The distance metric to use.",
            "sklearn": {
              "default_value": "'euclidean'",
              "path": "metric"
            }
          },
          {
            "name": "absolute_tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The desired absolute tolerance of the result. A larger tolerance will generally lead to faster execution. Default is 0.",
            "sklearn": {
              "default_value": "0",
              "path": "atol"
            }
          },
          {
            "name": "relative_tolerance",
            "kind_of_value": "float",
            "optional": "False",
            "description": "The desired relative tolerance of the result. A larger tolerance will generally lead to faster execution.",
            "sklearn": {
              "default_value": "0",
              "path": "rtol"
            }
          },
          {
            "name": "breadth_first",
            "kind_of_value": "boolean",
            "optional": "Fasle",
            "description": "If true (default), use a breadth-first approach to the problem. Otherwise use a depth-first approach.",
            "sklearn": {
              "default_value": "True",
              "path": "breadth_first"
            }
          },
          {
            "name": "leaf_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.",
            "sklearn": {
              "default_value": "40",
              "path": "leaf_size"
            }
          },
          {
            "name": "metric_parameters",
            "kind_of_value": "{dict, None}",
            "optional": "True",
            "description": "Additional keyword arguments for the metric function.",
            "sklearn": {
              "default_value": "None",
              "path": "metric_params"
            }
          }
        ],
        "optimisation_parameters": [],
        "execution_parameters": []
      }
    },
    {
      "name": "Bernoulli restricted Boltzmann machines",
      "other_names": [
        "Bernoulli RBM"
      ],
      "implementation": {
        "sklearn": "sklearn.neural_network.rbm.BernoulliRBM"
      },
      "type": "Unsupervised Neural Network Model",
      "hyper_parameters": {
        "model_parameters": [
          {
            "name": "num_components",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of binary hidden units.",
            "sklearn": {
              "default_value": "256",
              "path": "n_components"
            }
          },
          {
            "name": "learning_rate",
            "kind_of_value": "float",
            "optional": "True",
            "description": "The learning rate for weight updates.",
            "sklearn": {
              "default_value": "0.1",
              "path": "learning_rate"
            }
          },
          {
            "name": "batch_size",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of examples per minibatch.",
            "sklearn": {
              "default_value": "10",
              "path": "batch_size"
            }
          },
          {
            "name": "verbose",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "he verbosity level. The default, zero, means silent mode.",
            "sklearn": {
              "default_value": "0",
              "path": "verbose"
            }
          },
          {
            "name": "random_state",
            "kind_of_value": "{integer, RandomState instance, None}",
            "optional": "True",
            "description": "A random number generator instance to define the state of the random permutations generator. If an integer is given, it fixes the seed. Defaults to the global numpy random number generator.",
            "sklearn": {
              "default_value": "None",
              "path": "random_state"
            }
          }
        ],
        "optimisation_parameters": [
          {
            "name": "num_iter",
            "kind_of_value": "integer",
            "optional": "True",
            "description": "Number of iterations/sweeps over the training dataset to perform during training.",
            "sklearn": {
              "default_value": "10",
              "path": "n_iter"
            }
          }
        ],
        "execution_parameters": []
      }
    }
  ],
  "metadata": {
    "author": "Thomas Weißgerber",
    "library": "sklearn",
    "library_version": "0.19.1",
    "mapping_version": "0.1"
  }
}